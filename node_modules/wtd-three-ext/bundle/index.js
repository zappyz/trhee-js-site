var x = Object.defineProperty;
var O = (s, t, e) => t in s ? x(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var o = (s, t, e) => (O(s, typeof t != "symbol" ? t + "" : t, e), e);
import { MeshStandardMaterial as d, LineBasicMaterial as N, PointsMaterial as P, Texture as y, MaterialLoader as A, BufferGeometry as f, BufferAttribute as C, Box3 as _, Sphere as S, EventDispatcher as L } from "three";
class u {
  /**
   * Adds the provided material to the provided map of materials if the material does not exists.
   * Use force override existing material.
   *
   * @param {Map<string, Material>} materialsObject
   * @param {string} materialName
   * @param {Material} material
   * @param {boolean} force Enforce addition of provided material
   * @param {boolean} [log] Log messages to the console
   */
  static addMaterial(t, e, a, i, n) {
    let r;
    a.name = e, i ? (t.set(e, a), n && console.info('Material with name "' + e + '" was forcefully overridden.')) : (r = t.get(e), r ? r.uuid !== r.uuid && n && console.log('Same material name "' + r.name + '" different uuid [' + r.uuid + "|" + a.uuid + "]") : (t.set(e, a), n && console.info('Material with name "' + e + '" was added.')));
  }
  /**
   * Transforms the named materials object to an object with named jsonified materials.
   *
   * @param {Map<string, Material>}
   * @returns {Map<string, unknown>} Map of Materials in JSON representation
   */
  static getMaterialsJSON(t) {
    const e = /* @__PURE__ */ new Map();
    for (const a of t.entries())
      typeof a[1].toJSON == "function" && e.set(a[0], a[1].toJSON());
    return e;
  }
  /**
   * Clones a material according the provided instructions.
   *
   * @param {Map<string, Material>} materials
   * @param {MaterialCloneInstructionsType} materialCloneInstruction
   * @param {boolean} [log]
   */
  static cloneMaterial(t, e, a) {
    if (e) {
      let i = e.materialNameOrg;
      i = i ?? "";
      const n = t.get(i);
      if (n) {
        const r = n.clone();
        return Object.assign(r, e.materialProperties), u.addMaterial(t, e.materialProperties.name, r, !0, a), r;
      } else
        a && console.info('Requested material "' + i + '" is not available!');
    }
  }
}
class V {
  /**
   * Creates a new {@link MaterialStore}.
   * @param {boolean} createDefaultMaterials
   */
  constructor(t) {
    o(this, "materials");
    if (this.materials = /* @__PURE__ */ new Map(), t) {
      const e = new d({ color: 14479871 });
      e.name = "defaultMaterial";
      const a = new d({ color: 14479871 });
      a.name = "defaultVertexColorMaterial", a.vertexColors = !0;
      const i = new N();
      i.name = "defaultLineMaterial";
      const n = new P({ size: 0.1 });
      n.name = "defaultPointMaterial", this.materials.set(e.name, e), this.materials.set(a.name, a), this.materials.set(i.name, i), this.materials.set(n.name, n);
    }
  }
  /**
   * Set materials loaded by any supplier of an Array of {@link Material}.
   *
   * @param {Map<string, Material>} newMaterials Object with named {@link Material}
   * @param {boolean} forceOverrideExisting boolean Override existing material
   */
  addMaterials(t, e) {
    if (t && t !== null && t.size > 0)
      for (const a of t.entries())
        u.addMaterial(this.materials, a[0], a[1], e === !0);
  }
  addMaterialsFromObject(t, e) {
    if (t && t !== null && Object.keys(t).length > 0)
      for (const [a, i] of Object.entries(t))
        u.addMaterial(this.materials, a, i, e === !0);
  }
  getMaterials() {
    return this.materials;
  }
  getMaterial(t) {
    return this.materials.get(t);
  }
  clearMaterials() {
    this.materials.clear();
  }
}
var M;
(function(s) {
  s.INIT = "init", s.INIT_CHANNEL = "initChannel", s.INTERMEDIATE = "intermediate", s.EXECUTE = "execute", s.INTERCOM_INIT = "interComInit", s.INTERCOM_INTERMEDIATE = "interComIntermediate", s.INTERCOM_EXECUTE = "interComExecute";
})(M || (M = {}));
var p;
(function(s) {
  s.INIT_COMPLETE = "initComplete", s.INIT_CHANNEL_COMPLETE = "initChannelComplete", s.INTERMEDIATE_CONFIRM = "intermediateConfirm", s.EXECUTE_COMPLETE = "executeComplete", s.INTERCOM_INIT_COMPLETE = "interComInitComplete", s.INTERCOM_INTERMEDIATE_CONFIRM = "interComIntermediateConfirm", s.INTERCOM_EXECUTE_COMPLETE = "interComExecuteComplete";
})(p || (p = {}));
var E;
(function(s) {
  s.INIT_OFFSCREEN_CANVAS = "initOffscreenCanvas", s.PROXY_START = "proxyStart", s.PROXY_EVENT = "proxyEvent", s.RESIZE = "resize";
})(E || (E = {}));
var v;
(function(s) {
  s.INIT_OFFSCREEN_CANVAS_COMPLETE = "initOffscreenCanvasComplete", s.PROXY_START_COMPLETE = "proxyStartComplete", s.PROXY_EVENT_COMPLETE = "proxyEventComplete", s.RESIZE_COMPLETE = "resizeComplete";
})(v || (v = {}));
class g {
}
o(g, "handler", /* @__PURE__ */ new Map());
const m = (s, t, e) => {
  for (const a of s) {
    const i = e ? a.slice(0) : a, n = i.buffer;
    n ? t.push(n) : t.push(i);
  }
};
class D {
  constructor() {
    o(this, "$type", "DataPayload");
    o(this, "message", {
      buffers: /* @__PURE__ */ new Map(),
      params: {}
    });
    o(this, "progress", 0);
  }
}
class w {
  pack(t, e, a) {
    var n;
    const i = t;
    return i.message.buffers && m((n = i.message.buffers) == null ? void 0 : n.values(), e, a), e;
  }
  unpack(t, e) {
    const a = t, i = Object.assign(new D(), t);
    if (a.message.buffers)
      for (const [n, r] of a.message.buffers.entries())
        i.message.buffers && i.message.buffers.set(n, e ? r.slice(0) : r);
    return i;
  }
}
g.handler.set("DataPayload", new w());
class B {
  constructor() {
    o(this, "$type", "MaterialsPayload");
    o(this, "message", {
      buffers: /* @__PURE__ */ new Map(),
      params: {},
      materials: /* @__PURE__ */ new Map(),
      materialsJson: /* @__PURE__ */ new Map(),
      multiMaterialNames: /* @__PURE__ */ new Map(),
      cloneInstructions: []
    });
  }
  /**
   * Set an object containing named materials.
   * @param {Map<string, Material>} materials
   */
  setMaterials(t) {
    for (const [e, a] of t.entries())
      this.message.materials.set(e, a);
  }
  /**
  * Removes all textures and null values from all materials
  */
  cleanMaterials() {
    const t = /* @__PURE__ */ new Map();
    for (const e of this.message.materials.values())
      if (typeof e.clone == "function") {
        const a = e.clone();
        t.set(a.name, this.cleanMaterial(a));
      }
    this.message.materials = t;
  }
  cleanMaterial(t) {
    const e = t;
    for (const [a, i] of Object.entries(e))
      (i instanceof y || i === null) && Object.prototype.hasOwnProperty.call(t, a) && (e[a] = void 0);
    return t;
  }
  /**
    * Tell whether a multi-material was defined
    * @return {boolean}
    */
  hasMultiMaterial() {
    return this.message.multiMaterialNames.size > 0;
  }
  /**
   * Returns a single material if it is defined or null.
   * @return {Material|null}
   */
  getSingleMaterial() {
    return this.message.materials.size > 0 ? this.message.materials.values().next().value : void 0;
  }
  /**
   * Adds contained material or multi-material the provided materials object or it clones and adds new materials according clone instructions.
   *
   * @param {Map<string, Material>} materials
   * @param {boolean} log
   *
   * @return {Material|Material[]|undefined}
   */
  processMaterialTransport(t, e) {
    for (const a of this.message.cloneInstructions)
      u.cloneMaterial(t, a, e);
    if (this.hasMultiMaterial()) {
      const a = [];
      for (const [i, n] of this.message.multiMaterialNames.entries()) {
        const r = t.get(n);
        r && (a[i] = r);
      }
      return a;
    } else {
      const a = this.getSingleMaterial();
      if (a) {
        const i = t.get(a.name);
        return i || a;
      }
    }
  }
}
class R {
  pack(t, e, a) {
    const i = t;
    return i.message.buffers && m(i.message.buffers.values(), e, a), i.message.materialsJson = u.getMaterialsJSON(i.message.materials), e;
  }
  unpack(t, e) {
    const a = t, i = Object.assign(new B(), t);
    new w().unpack(a, e);
    for (const [r, h] of a.message.multiMaterialNames.entries())
      i.message.multiMaterialNames.set(r, h);
    const n = new A();
    for (const [r, h] of a.message.materialsJson.entries())
      i.message.materials.set(r, n.parse(h));
    return i;
  }
}
g.handler.set("MaterialsPayload", new R());
class z {
  constructor() {
    o(this, "$type", "MeshPayload");
    o(this, "message", {
      params: {},
      buffers: /* @__PURE__ */ new Map(),
      geometryType: 0,
      bufferGeometry: new f(),
      meshName: ""
    });
  }
  /**
   * Set the {@link BufferGeometry} and geometry type that can be used when a mesh is created.
   *
   * @param {BufferGeometry} bufferGeometry
   * @param {number} geometryType [0=Mesh|1=LineSegments|2=Points]
   */
  setBufferGeometry(t, e) {
    this.message.bufferGeometry = t, this.message.geometryType = e;
  }
  /**
   * Sets the mesh and the geometry type [0=Mesh|1=LineSegments|2=Points]
   * @param {Mesh} mesh
   * @param {number} geometryType
   */
  setMesh(t, e) {
    this.message.meshName = t.name, this.setBufferGeometry(t.geometry, e);
  }
}
class X {
  pack(t, e, a) {
    const i = t;
    return i.message.buffers && (j(a, i.message.bufferGeometry, i.message.buffers), m(i.message.buffers.values(), e, a)), e;
  }
  unpack(t, e) {
    const a = t, i = Object.assign(new z(), a);
    return i.message.bufferGeometry && (i.message.bufferGeometry = F(e, i.message.bufferGeometry)), i;
  }
}
const j = (s, t, e) => {
  if (!(t instanceof f))
    return;
  const a = t.getAttribute("position"), i = t.getAttribute("normal"), n = t.getAttribute("uv"), r = t.getAttribute("color"), h = t.getAttribute("skinIndex"), T = t.getAttribute("skinWeight"), b = t.getIndex();
  l("position", a, s, e), l("normal", i, s, e), l("uv", n, s, e), l("color", r, s, e), l("skinIndex", h, s, e), l("skinWeight", T, s, e), l("index", b, s, e);
}, l = (s, t, e, a) => {
  if (t && t !== null) {
    const i = t.array;
    a.set(s, e ? i.slice(0) : i);
  }
}, F = (s, t) => {
  const e = new f();
  if (t) {
    if (t instanceof f)
      return t;
  } else
    return e;
  if (t.attributes) {
    const n = t.attributes;
    c(e, n.position, "position", s), c(e, n.normal, "normal", s), c(e, n.uv, "uv", s), c(e, n.color, "color", s), c(e, n.skinIndex, "skinIndex", s), c(e, n.skinWeight, "skinWeight", s);
  }
  if (t.index !== null) {
    const n = t.index;
    if (n) {
      const r = s ? n.array.slice(0) : n.array;
      e.setIndex(new C(r, n.itemSize, n.normalized));
    }
  }
  const a = t.boundingBox;
  a !== null && (e.boundingBox = Object.assign(new _(), a));
  const i = t.boundingSphere;
  return i !== null && (e.boundingSphere = Object.assign(new S(), i)), e.uuid = t.uuid, e.name = t.name, e.groups = t.groups, e.drawRange = t.drawRange, e.userData = t.userData, e;
}, c = (s, t, e, a) => {
  if (t) {
    const i = a ? t.array.slice(0) : t.array;
    s.setAttribute(e, new C(i, t.itemSize, t.normalized));
  }
};
g.handler.set("MeshPayload", new X());
const I = () => {
};
class Y extends L {
  constructor() {
    super();
    o(this, "top", 0);
    o(this, "left", 0);
    o(this, "clientLeft", 0);
    o(this, "clientTop", 0);
    o(this, "pageXOffset", 0);
    o(this, "pageYOffset", 0);
    o(this, "style", {});
    o(this, "ownerDocument", {
      documentElement: {}
    });
    o(this, "offscreenCanvas", new OffscreenCanvas(100, 100));
    o(this, "oncontextlost", null);
    o(this, "oncontextrestored", null);
    this.ownerDocument.documentElement = this;
  }
  merge(e) {
    this.offscreenCanvas = e, this.width = e.width, this.height = e.height, this.oncontextlost = e.oncontextlost, this.oncontextrestored = e.oncontextrestored;
  }
  getContext(e, a) {
    return this.offscreenCanvas.getContext(e, a) ?? null;
  }
  transferToImageBitmap() {
    return this.offscreenCanvas.transferToImageBitmap();
  }
  convertToBlob(e) {
    return this.offscreenCanvas.convertToBlob(e);
  }
  get height() {
    return this.offscreenCanvas.height;
  }
  set height(e) {
    this.offscreenCanvas.height = e;
  }
  get width() {
    return this.offscreenCanvas.width;
  }
  set width(e) {
    this.offscreenCanvas.width = e;
  }
  get clientWidth() {
    return this.width;
  }
  get clientHeight() {
    return this.height;
  }
  setPointerCapture(e) {
  }
  releasePointerCapture(e) {
  }
  getBoundingClientRect() {
    return {
      left: this.left,
      top: this.top,
      width: this.width,
      height: this.height,
      right: this.left + this.width,
      bottom: this.top + this.height
    };
  }
  handleEvent(e) {
    e.preventDefault = I, e.stopPropagation = I, this.dispatchEvent(e);
  }
  focus() {
  }
}
const U = (s) => {
  self.window = s, self.document = {
    addEventListener: s.addEventListener.bind(s),
    removeEventListener: s.removeEventListener.bind(s)
  };
};
export {
  Y as ElementProxyReceiver,
  V as MaterialStore,
  u as MaterialUtils,
  B as MaterialsPayload,
  z as MeshPayload,
  X as MeshPayloadHandler,
  l as addAttributeToBuffers,
  c as assignAttributeFromTransfered,
  I as noop,
  j as packGeometryBuffers,
  U as proxyStart,
  F as reconstructBuffer
};
