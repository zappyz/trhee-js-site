import { MaterialUtils } from './MaterialUtils.js';
import { MeshStandardMaterial, LineBasicMaterial, PointsMaterial } from 'three';
/**
 * Helper class around an object storing materials by name.
 * Optionally, create and store default materials.
 */
export class MaterialStore {
    materials;
    /**
     * Creates a new {@link MaterialStore}.
     * @param {boolean} createDefaultMaterials
     */
    constructor(createDefaultMaterials) {
        this.materials = new Map();
        if (createDefaultMaterials) {
            const defaultMaterial = new MeshStandardMaterial({ color: 0xDCF1FF });
            defaultMaterial.name = 'defaultMaterial';
            const defaultVertexColorMaterial = new MeshStandardMaterial({ color: 0xDCF1FF });
            defaultVertexColorMaterial.name = 'defaultVertexColorMaterial';
            defaultVertexColorMaterial.vertexColors = true;
            const defaultLineMaterial = new LineBasicMaterial();
            defaultLineMaterial.name = 'defaultLineMaterial';
            const defaultPointMaterial = new PointsMaterial({ size: 0.1 });
            defaultPointMaterial.name = 'defaultPointMaterial';
            this.materials.set(defaultMaterial.name, defaultMaterial);
            this.materials.set(defaultVertexColorMaterial.name, defaultVertexColorMaterial);
            this.materials.set(defaultLineMaterial.name, defaultLineMaterial);
            this.materials.set(defaultPointMaterial.name, defaultPointMaterial);
        }
    }
    /**
     * Set materials loaded by any supplier of an Array of {@link Material}.
     *
     * @param {Map<string, Material>} newMaterials Object with named {@link Material}
     * @param {boolean} forceOverrideExisting boolean Override existing material
     */
    addMaterials(newMaterials, forceOverrideExisting) {
        if (newMaterials && newMaterials !== null && newMaterials.size > 0) {
            for (const entry of newMaterials.entries()) {
                MaterialUtils.addMaterial(this.materials, entry[0], entry[1], forceOverrideExisting === true);
            }
        }
    }
    addMaterialsFromObject(newMaterials, forceOverrideExisting) {
        if (newMaterials && newMaterials !== null && Object.keys(newMaterials).length > 0) {
            for (const [k, v] of Object.entries(newMaterials)) {
                MaterialUtils.addMaterial(this.materials, k, v, forceOverrideExisting === true);
            }
        }
    }
    getMaterials() {
        return this.materials;
    }
    getMaterial(materialName) {
        return this.materials.get(materialName);
    }
    clearMaterials() {
        this.materials.clear();
    }
}
//# sourceMappingURL=MaterialStore.js.map