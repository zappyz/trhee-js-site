import { PayloadRegister, fillTransferables } from 'wtd-core';
import { Box3, BufferAttribute, BufferGeometry, Sphere } from 'three';
export var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["MESH"] = 0] = "MESH";
    GeometryType[GeometryType["LINE"] = 1] = "LINE";
    GeometryType[GeometryType["POINT"] = 2] = "POINT";
})(GeometryType || (GeometryType = {}));
export class MeshPayload {
    $type = 'MeshPayload';
    message = {
        params: {},
        buffers: new Map(),
        geometryType: GeometryType.MESH,
        bufferGeometry: new BufferGeometry(),
        meshName: ''
    };
    /**
     * Set the {@link BufferGeometry} and geometry type that can be used when a mesh is created.
     *
     * @param {BufferGeometry} bufferGeometry
     * @param {number} geometryType [0=Mesh|1=LineSegments|2=Points]
     */
    setBufferGeometry(bufferGeometry, geometryType) {
        this.message.bufferGeometry = bufferGeometry;
        this.message.geometryType = geometryType;
    }
    /**
     * Sets the mesh and the geometry type [0=Mesh|1=LineSegments|2=Points]
     * @param {Mesh} mesh
     * @param {number} geometryType
     */
    setMesh(mesh, geometryType) {
        this.message.meshName = mesh.name;
        this.setBufferGeometry(mesh.geometry, geometryType);
    }
}
export class MeshPayloadHandler {
    pack(payload, transferables, cloneBuffers) {
        const mp = payload;
        if (mp.message.buffers) {
            packGeometryBuffers(cloneBuffers, mp.message.bufferGeometry, mp.message.buffers);
            fillTransferables(mp.message.buffers.values(), transferables, cloneBuffers);
        }
        return transferables;
    }
    unpack(transportObject, cloneBuffers) {
        const mp = transportObject;
        const meshPayload = Object.assign(new MeshPayload(), mp);
        if (meshPayload.message.bufferGeometry) {
            meshPayload.message.bufferGeometry = reconstructBuffer(cloneBuffers, meshPayload.message.bufferGeometry);
        }
        return meshPayload;
    }
}
export const packGeometryBuffers = (cloneBuffers, bufferGeometry, buffers) => {
    // fast-fail
    if (!(bufferGeometry instanceof BufferGeometry))
        return;
    const vertexBA = bufferGeometry.getAttribute('position');
    const normalBA = bufferGeometry.getAttribute('normal');
    const uvBA = bufferGeometry.getAttribute('uv');
    const colorBA = bufferGeometry.getAttribute('color');
    const skinIndexBA = bufferGeometry.getAttribute('skinIndex');
    const skinWeightBA = bufferGeometry.getAttribute('skinWeight');
    const indexBA = bufferGeometry.getIndex();
    addAttributeToBuffers('position', vertexBA, cloneBuffers, buffers);
    addAttributeToBuffers('normal', normalBA, cloneBuffers, buffers);
    addAttributeToBuffers('uv', uvBA, cloneBuffers, buffers);
    addAttributeToBuffers('color', colorBA, cloneBuffers, buffers);
    addAttributeToBuffers('skinIndex', skinIndexBA, cloneBuffers, buffers);
    addAttributeToBuffers('skinWeight', skinWeightBA, cloneBuffers, buffers);
    addAttributeToBuffers('index', indexBA, cloneBuffers, buffers);
};
export const addAttributeToBuffers = (name, input, cloneBuffer, buffers) => {
    if (input && input !== null) {
        const typedArray = input.array;
        buffers.set(name, cloneBuffer ? typedArray.slice(0) : typedArray);
    }
};
export const reconstructBuffer = (cloneBuffers, transferredGeometry) => {
    const bufferGeometry = new BufferGeometry();
    // fast-fail: transferredGeometry is either rubbish or already a bufferGeometry
    if (!transferredGeometry) {
        return bufferGeometry;
    }
    else if (transferredGeometry instanceof BufferGeometry) {
        return transferredGeometry;
    }
    if (transferredGeometry.attributes) {
        const attr = transferredGeometry.attributes;
        assignAttributeFromTransfered(bufferGeometry, attr.position, 'position', cloneBuffers);
        assignAttributeFromTransfered(bufferGeometry, attr.normal, 'normal', cloneBuffers);
        assignAttributeFromTransfered(bufferGeometry, attr.uv, 'uv', cloneBuffers);
        assignAttributeFromTransfered(bufferGeometry, attr.color, 'color', cloneBuffers);
        assignAttributeFromTransfered(bufferGeometry, attr.skinIndex, 'skinIndex', cloneBuffers);
        assignAttributeFromTransfered(bufferGeometry, attr.skinWeight, 'skinWeight', cloneBuffers);
    }
    // TODO: morphAttributes
    if (transferredGeometry.index !== null) {
        const indexAttr = transferredGeometry.index;
        if (indexAttr) {
            const indexBuffer = cloneBuffers ? indexAttr.array.slice(0) : indexAttr.array;
            bufferGeometry.setIndex(new BufferAttribute(indexBuffer, indexAttr.itemSize, indexAttr.normalized));
        }
    }
    const boundingBox = transferredGeometry.boundingBox;
    if (boundingBox !== null) {
        bufferGeometry.boundingBox = Object.assign(new Box3(), boundingBox);
    }
    const boundingSphere = transferredGeometry.boundingSphere;
    if (boundingSphere !== null) {
        bufferGeometry.boundingSphere = Object.assign(new Sphere(), boundingSphere);
    }
    bufferGeometry.uuid = transferredGeometry.uuid;
    bufferGeometry.name = transferredGeometry.name;
    bufferGeometry.groups = transferredGeometry.groups;
    bufferGeometry.drawRange = transferredGeometry.drawRange;
    bufferGeometry.userData = transferredGeometry.userData;
    return bufferGeometry;
};
export const assignAttributeFromTransfered = (bufferGeometry, input, attrName, cloneBuffer) => {
    if (input) {
        const arrayLike = cloneBuffer ? input.array.slice(0) : input.array;
        bufferGeometry.setAttribute(attrName, new BufferAttribute(arrayLike, input.itemSize, input.normalized));
    }
};
// register the Mesh related payload handler
PayloadRegister.handler.set('MeshPayload', new MeshPayloadHandler());
//# sourceMappingURL=MeshPayload.js.map