import { Payload } from './Payload.js';
import { WorkerTaskMessage } from './WorkerTaskMessage.js';
export declare enum WorkerTaskCommandRequest {
    INIT = "init",
    INIT_CHANNEL = "initChannel",
    INTERMEDIATE = "intermediate",
    EXECUTE = "execute",
    INTERCOM_INIT = "interComInit",
    INTERCOM_INTERMEDIATE = "interComIntermediate",
    INTERCOM_EXECUTE = "interComExecute"
}
export declare enum WorkerTaskCommandResponse {
    INIT_COMPLETE = "initComplete",
    INIT_CHANNEL_COMPLETE = "initChannelComplete",
    INTERMEDIATE_CONFIRM = "intermediateConfirm",
    EXECUTE_COMPLETE = "executeComplete",
    INTERCOM_INIT_COMPLETE = "interComInitComplete",
    INTERCOM_INTERMEDIATE_CONFIRM = "interComIntermediateConfirm",
    INTERCOM_EXECUTE_COMPLETE = "interComExecuteComplete"
}
export type WorkerTaskWorker = {
    init?(message: WorkerTaskMessage): void;
    initChannel?(message: WorkerTaskMessage): void;
    intermediate?(message: WorkerTaskMessage): void;
    execute(message: WorkerTaskMessage): void;
};
export type InterComWorker = {
    interComInit?(message: WorkerTaskMessage): void;
    interComInitComplete?(message: WorkerTaskMessage): void;
    interComIntermediate?(message: WorkerTaskMessage): void;
    interComIntermediateConfirm?(message: WorkerTaskMessage): void;
    interComExecute?(message: WorkerTaskMessage): void;
    interComExecuteComplete?(message: WorkerTaskMessage): void;
};
export declare class InterComPortHandler {
    private ports;
    registerPort(name: string, payload: Payload | undefined, onmessage: (message: MessageEvent<unknown>) => void): void;
    postMessageOnPort(target: string, message: WorkerTaskMessage, options?: StructuredSerializeOptions): void;
}
export declare const comRouting: (workerImpl: WorkerTaskWorker | InterComWorker, message: MessageEvent<unknown>) => void;
//# sourceMappingURL=WorkerTaskWorker.d.ts.map