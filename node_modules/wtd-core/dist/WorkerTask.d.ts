import { WorkerTaskMessage } from './WorkerTaskMessage.js';
export type WorkerConfig = {
    $type: 'WorkerConfigParams';
    workerType: 'classic' | 'module';
    blob?: boolean;
    url: URL | string | undefined;
};
export type WorkerConfigDirect = {
    $type: 'WorkerConfigDirect';
    worker: Worker;
};
export type WorkerMessageDef = {
    message: WorkerTaskMessage;
    transferables?: Transferable[];
    copyTransferables?: boolean;
};
export type WorkerIntermediateMessageDef = WorkerMessageDef & {
    answer?: string;
    awaitAnswer?: boolean;
};
export type WorkerExecutionDef = {
    message: WorkerTaskMessage;
    onComplete?: (message: WorkerTaskMessage) => void;
    onIntermediateConfirm?: (message: WorkerTaskMessage) => void;
    transferables?: Transferable[];
    copyTransferables?: boolean;
};
export type WorkerTaskConfig = {
    taskName: string;
    workerId: number;
    workerConfig: WorkerConfig | WorkerConfigDirect;
    verbose?: boolean;
};
export declare class WorkerTask {
    private taskName;
    private workerId;
    private workerConfig;
    private verbose;
    private worker?;
    private executing;
    private executionCounter;
    private awaitAnswers;
    constructor(config: WorkerTaskConfig);
    isWorkerExecuting(): boolean;
    markExecuting(executing: boolean): void;
    getWorker(): Worker | undefined;
    connectWorker(): void;
    initWorker(def: WorkerMessageDef): Promise<WorkerTaskMessage>;
    executeWorker(def: WorkerExecutionDef): Promise<WorkerTaskMessage>;
    /**
     * This is only possible if the worker is available.
     */
    sentMessage(def: WorkerIntermediateMessageDef): Promise<WorkerTaskMessage>;
    private updateAwaitHandlers;
    private buildUuid;
    private handleTransferables;
    private checkWorker;
    dispose(): void;
    printAwaitAnswers(): void;
}
//# sourceMappingURL=WorkerTask.d.ts.map