/**
 * Inspired by:
 * https://threejs.org/manual/#en/offscreencanvas
 * https://jsfiddle.net/greggman/kuLdptmq/17/
 */
import { WorkerTaskMessage } from '../WorkerTaskMessage.js';
import { OffscreenPayload } from './OffscreenPayload.js';
import { OffscreenWorkerCommandRequest, OffscreenWorkerCommandResponse } from './OffscreenWorker.js';
export const handlePreventDefault = (event) => {
    event.preventDefault();
};
export const MouseEventProperties = [
    'ctrlKey',
    'metaKey',
    'shiftKey',
    'button',
    'pointerType',
    'pointerId',
    'clientX',
    'clientY',
    'pageX',
    'pageY',
];
export const handleMouseEvent = (event, workerTask, properties) => {
    const offscreenPayload = extractProperties(event, properties);
    workerTask.sentMessage({
        message: WorkerTaskMessage.fromPayload(offscreenPayload, 'proxyEvent')
    });
};
export const WheelEventProperties = [
    'deltaX',
    'deltaY',
];
export const handleWheelEvent = (event, workerTask, properties) => {
    const offscreenPayload = extractProperties(event, properties);
    workerTask.sentMessage({
        message: WorkerTaskMessage.fromPayload(offscreenPayload, 'proxyEvent')
    });
};
export const KeydownEventProperties = [
    'ctrlKey',
    'altKey',
    'metaKey',
    'shiftKey',
    'code',
];
// The four arrow keys
export const AllowedKeyProperties = [
    'ArrowLeft',
    'ArrowUp',
    'ArrowRight',
    'ArrowDown',
    'KeyW',
    'KeyA',
    'KeyS',
    'KeyD'
];
export const handleFilteredKeydownEvent = (event, workerTask, properties, positiveList) => {
    const { code } = event;
    if (positiveList?.includes(code)) {
        const offscreenPayload = extractProperties(event, properties);
        workerTask.sentMessage({
            message: WorkerTaskMessage.fromPayload(offscreenPayload, 'proxyEvent')
        });
    }
};
export const extractProperties = (event, properties) => {
    const eventTarget = {
        type: event.type,
    };
    if (properties) {
        for (const name of properties) {
            eventTarget[name] = event[name];
        }
    }
    return new OffscreenPayload({
        event: eventTarget
    });
};
export const handleTouchEvent = (event, workerTask) => {
    const touches = [];
    const touchEvent = event;
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < touchEvent.touches.length; ++i) {
        const touch = touchEvent.touches[i];
        touches.push({
            pageX: touch.pageX,
            pageY: touch.pageY,
        });
    }
    const offscreenPayload = new OffscreenPayload({
        event: {
            type: event.type,
            touches
        }
    });
    workerTask.sentMessage({
        message: WorkerTaskMessage.fromPayload(offscreenPayload, OffscreenWorkerCommandRequest.PROXY_EVENT)
    });
};
export const buildDefaultEventHandlingInstructions = () => {
    const handlingInstructions = new Map();
    const contextMenuInstruction = {
        handler: handlePreventDefault
    };
    const mouseInstruction = {
        handler: handleMouseEvent,
        properties: MouseEventProperties
    };
    const wheelInstruction = {
        handler: handleWheelEvent,
        properties: WheelEventProperties,
        passive: true
    };
    const keyboardInstruction = {
        handler: handleFilteredKeydownEvent,
        properties: KeydownEventProperties,
        positiveList: AllowedKeyProperties
    };
    const touchInstruction = {
        handler: handleTouchEvent,
        passive: true
    };
    handlingInstructions.set('contextmenu', contextMenuInstruction);
    handlingInstructions.set('mousedown', mouseInstruction);
    handlingInstructions.set('mousemove', mouseInstruction);
    handlingInstructions.set('mouseup', mouseInstruction);
    handlingInstructions.set('pointerdown', mouseInstruction);
    handlingInstructions.set('pointermove', mouseInstruction);
    handlingInstructions.set('pointerup', mouseInstruction);
    handlingInstructions.set('wheel', wheelInstruction);
    handlingInstructions.set('keydown', keyboardInstruction);
    handlingInstructions.set('touchstart', touchInstruction);
    handlingInstructions.set('touchmove', touchInstruction);
    handlingInstructions.set('touchend', touchInstruction);
    return handlingInstructions;
};
export const registerCanvas = async (workerTask, canvas, handlingInstructions) => {
    canvas.focus();
    await workerTask.sentMessage({
        message: WorkerTaskMessage.fromPayload(new OffscreenPayload({}), OffscreenWorkerCommandRequest.PROXY_START),
        awaitAnswer: true,
        answer: OffscreenWorkerCommandResponse.PROXY_START_COMPLETE
    });
    for (const [eventName, instruction] of handlingInstructions.entries()) {
        if (eventName.startsWith('key')) {
            window.addEventListener(eventName, (event) => {
                instruction.handler(event, workerTask, instruction.properties, instruction.positiveList);
            }, instruction.passive === true ? { passive: true } : undefined);
        }
        else {
            canvas.addEventListener(eventName, (event) => {
                instruction.handler(event, workerTask, instruction.properties);
            }, instruction.passive === true ? { passive: true } : undefined);
        }
    }
};
export const sentResize = (workerTask, canvas) => {
    const dataPayload = new OffscreenPayload({
        width: canvas.offsetWidth,
        height: canvas.offsetHeight,
        pixelRatio: window.devicePixelRatio
    });
    workerTask.sentMessage({
        message: WorkerTaskMessage.fromPayload(dataPayload, OffscreenWorkerCommandRequest.RESIZE),
    });
};
export const registerResizeHandler = (workerTask, canvas) => {
    window.addEventListener('resize', () => sentResize(workerTask, canvas), false);
};
//# sourceMappingURL=MainEventProxy.js.map