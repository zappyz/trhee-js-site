var y = Object.defineProperty;
var v = (s, e, t) => e in s ? y(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var a = (s, e, t) => (v(s, typeof e != "symbol" ? e + "" : e, t), t);
var w = /* @__PURE__ */ ((s) => (s.INIT = "init", s.INIT_CHANNEL = "initChannel", s.INTERMEDIATE = "intermediate", s.EXECUTE = "execute", s.INTERCOM_INIT = "interComInit", s.INTERCOM_INTERMEDIATE = "interComIntermediate", s.INTERCOM_EXECUTE = "interComExecute", s))(w || {}), u = /* @__PURE__ */ ((s) => (s.INIT_COMPLETE = "initComplete", s.INIT_CHANNEL_COMPLETE = "initChannelComplete", s.INTERMEDIATE_CONFIRM = "intermediateConfirm", s.EXECUTE_COMPLETE = "executeComplete", s.INTERCOM_INIT_COMPLETE = "interComInitComplete", s.INTERCOM_INTERMEDIATE_CONFIRM = "interComIntermediateConfirm", s.INTERCOM_EXECUTE_COMPLETE = "interComExecuteComplete", s))(u || {});
class $ {
  constructor() {
    a(this, "ports", /* @__PURE__ */ new Map());
  }
  registerPort(e, t, r) {
    const o = t ? t.message.raw.port : void 0;
    if (!o)
      throw new Error(`${(t == null ? void 0 : t.message) ?? "undefined"} is not a RawPayload. Unable to extract a port.`);
    this.ports.set(e, o), o.onmessage = r;
  }
  postMessageOnPort(e, t, r) {
    var o;
    (o = this.ports.get(e)) == null || o.postMessage(t, r);
  }
}
const H = (s, e) => {
  const t = e.data;
  if (t && t.cmd) {
    const r = s, o = t.cmd ?? "unknown";
    typeof r[o] == "function" ? r[o](t) : console.warn(`No function "${o}" found on workerImpl.`);
  } else
    console.error(`Received: unknown message: ${t}`);
};
var h = /* @__PURE__ */ ((s) => (s.INIT_OFFSCREEN_CANVAS = "initOffscreenCanvas", s.PROXY_START = "proxyStart", s.PROXY_EVENT = "proxyEvent", s.RESIZE = "resize", s))(h || {}), m = /* @__PURE__ */ ((s) => (s.INIT_OFFSCREEN_CANVAS_COMPLETE = "initOffscreenCanvasComplete", s.PROXY_START_COMPLETE = "proxyStartComplete", s.PROXY_EVENT_COMPLETE = "proxyEventComplete", s.RESIZE_COMPLETE = "resizeComplete", s))(m || {});
class d {
}
a(d, "handler", /* @__PURE__ */ new Map());
class c {
  constructor(e) {
    a(this, "cmd", "unknown");
    a(this, "uuid", "unknown");
    a(this, "name", "unnamed");
    a(this, "workerId", 0);
    a(this, "progress", 0);
    a(this, "payloads", []);
    this.cmd = (e == null ? void 0 : e.cmd) ?? this.cmd, this.name = (e == null ? void 0 : e.name) ?? this.name, this.workerId = (e == null ? void 0 : e.workerId) ?? this.workerId, this.progress = (e == null ? void 0 : e.progress) ?? this.progress;
  }
  addPayload(e) {
    e && (Array.isArray(e) ? this.payloads = this.payloads.concat(e) : this.payloads.push(e));
  }
  static createNew(e) {
    return new c(e);
  }
  static createEmpty() {
    return c.createNew({});
  }
  static createFromExisting(e, t) {
    const r = c.createNew(e);
    return r.uuid = e.uuid, t != null && t.overrideCmd && (r.cmd = t.overrideCmd), t != null && t.overrideUuid && (r.uuid = t.overrideUuid), r;
  }
  static pack(e, t) {
    const r = [];
    if (e)
      for (const o of e) {
        const n = d.handler.get(o.$type);
        n == null || n.pack(o, r, t === !0);
      }
    return r;
  }
  static unpack(e, t) {
    const r = c.createFromExisting(e, {
      overrideUuid: e.uuid
    });
    if (e.payloads)
      for (const o of e.payloads) {
        const n = d.handler.get(o.$type);
        r.addPayload(n == null ? void 0 : n.unpack(o, t === !0));
      }
    return r;
  }
  static fromPayload(e, t) {
    const r = c.createNew({
      cmd: t
    });
    return r.addPayload(e), r;
  }
}
class I {
  constructor(e) {
    a(this, "taskName");
    a(this, "workerId");
    a(this, "workerConfig");
    a(this, "verbose", !1);
    a(this, "worker");
    a(this, "executing", !1);
    a(this, "executionCounter", 0);
    a(this, "awaitAnswers", /* @__PURE__ */ new Map());
    this.taskName = e.taskName, this.workerId = e.workerId, this.workerConfig = e.workerConfig, this.verbose = e.verbose === !0;
  }
  isWorkerExecuting() {
    return this.executing;
  }
  markExecuting(e) {
    this.executing = e;
  }
  getWorker() {
    return this.worker;
  }
  connectWorker() {
    if (this.worker)
      throw new Error("Worker already created. Aborting...");
    if (this.workerConfig.$type === "WorkerConfigDirect" ? this.worker = this.workerConfig.worker : this.workerConfig.$type === "WorkerConfigParams" && this.workerConfig.url && (this.workerConfig.blob ? this.worker = new Worker(this.workerConfig.url) : this.worker = new Worker(this.workerConfig.url.href, {
      type: this.workerConfig.workerType
    })), !this.worker)
      throw new Error("No valid worker configuration was supplied. Aborting...");
    this.worker.onmessage = async (e) => {
      const t = e.data;
      if (t.cmd) {
        const r = this.awaitAnswers.get(t.uuid ?? "unknown");
        r == null || r.forEach((o) => {
          if (o.name === t.cmd) {
            if (o.log === !0) {
              const n = `Received: ${t.cmd} (workerName: ${t.name ?? "unknown"}) with uuid: ${t.uuid}`;
              console.log(n);
            }
            for (const n of o.resolve)
              n(t);
            o.endExecution === !0 && this.markExecuting(!1), o.remove === !0 && this.awaitAnswers.delete(t.uuid);
          }
        });
      } else
        console.error(`Received: unknown message: ${t}`);
    }, this.worker.onerror = async (e) => {
      console.log(`Execution Aborted: ${e.error}`), Promise.reject(e), this.markExecuting(!1);
    };
  }
  async initWorker(e) {
    return new Promise((t, r) => {
      var o;
      if (!this.worker)
        r(new Error("No worker is available. Aborting...")), this.markExecuting(!1);
      else {
        this.verbose && console.log(`Task: ${this.taskName}: Waiting for completion of worker init.`);
        const n = e.message;
        n.cmd = w.INIT;
        const i = this.handleTransferables(e);
        this.updateAwaitHandlers(n, [{
          name: u.INIT_COMPLETE,
          resolve: [t],
          reject: r,
          remove: !0,
          log: this.verbose
        }]), (o = this.worker) == null || o.postMessage(n, i);
      }
    });
  }
  async executeWorker(e) {
    return new Promise((t, r) => {
      if (!this.worker)
        r(new Error("No worker is available. Aborting...")), this.markExecuting(!1);
      else {
        this.markExecuting(!0);
        const o = e.message;
        o.cmd = w.EXECUTE;
        const n = this.handleTransferables(e), i = [], l = [];
        e.onComplete && l.push(e.onComplete), l.push(t), i.push({
          name: u.EXECUTE_COMPLETE,
          resolve: l,
          reject: r,
          remove: !0,
          endExecution: !0,
          log: this.verbose
        }), typeof e.onIntermediateConfirm == "function" && i.push({
          name: u.INTERMEDIATE_CONFIRM,
          resolve: [e.onIntermediateConfirm],
          reject: r,
          remove: !1,
          log: this.verbose
        }), this.updateAwaitHandlers(o, i), this.worker.postMessage(o, n);
      }
    });
  }
  /**
   * This is only possible if the worker is available.
   */
  sentMessage(e) {
    return new Promise((t, r) => {
      var o;
      if (this.checkWorker(r)) {
        const n = e.message;
        if (n.cmd === "unknown" || n.cmd.length === 0)
          throw new Error("No command provided. Aborting...");
        const i = this.handleTransferables(e);
        if (e.awaitAnswer === !0) {
          if (!e.answer) {
            r(new Error("No answer name provided. Aborting..."));
            return;
          }
          this.updateAwaitHandlers(n, [{
            name: e.answer,
            resolve: [t],
            reject: r,
            remove: !0,
            log: this.verbose
          }]);
        }
        (o = this.worker) == null || o.postMessage(n, i), e.awaitAnswer || t(c.createEmpty());
      }
    });
  }
  updateAwaitHandlers(e, t) {
    e.workerId = this.workerId, e.uuid = this.buildUuid(), this.awaitAnswers.set(e.uuid, t);
  }
  buildUuid() {
    return `${this.workerId}_${this.executionCounter++}_${Math.floor(Math.random() * 1e8)}`;
  }
  handleTransferables(e) {
    let t = [];
    if (e.transferables)
      if (e.copyTransferables === !0)
        for (const r of e.transferables)
          t.push(r.slice(0));
      else
        t = e.transferables;
    return t;
  }
  checkWorker(e) {
    return this.worker ? !0 : (e(new Error("No worker is available. Aborting...")), this.markExecuting(!1), !1);
  }
  dispose() {
    var e;
    (e = this.worker) == null || e.terminate();
  }
  printAwaitAnswers() {
    console.log(`${this.taskName}: awaitAnswers:`), console.log(this.awaitAnswers);
  }
}
const f = class f {
  constructor(e) {
    a(this, "defaultMaxParallelExecutions");
    a(this, "verbose", !1);
    a(this, "taskTypes");
    a(this, "workerExecutionPlans");
    this.defaultMaxParallelExecutions = (e == null ? void 0 : e.defaultMaxParallelExecutions) ?? f.DEFAULT_MAX_PARALLEL_EXECUTIONS, this.verbose = (e == null ? void 0 : e.verbose) === !0, this.taskTypes = /* @__PURE__ */ new Map(), this.workerExecutionPlans = /* @__PURE__ */ new Map();
  }
  /**
   * Registers functionality for a new task type based on workerRegistration info
   *
   * @param {string} taskName The name to be used for registration.
   * @param {WorkerConfig | WorkerConfigDirect} workerConfig information regarding the worker to be registered
   * @param {number} maxParallelExecutions Number of maximum parallel executions allowed
   * @return {boolean} Tells if registration is possible (new=true) or if task was already registered (existing=false)
   */
  registerTask(e) {
    const t = e.taskName, r = !this.taskTypes.has(t);
    if (r) {
      const o = e.maxParallelExecutions ?? this.defaultMaxParallelExecutions, n = {
        workerTasks: /* @__PURE__ */ new Map(),
        maxParallelExecutions: o
      };
      this.taskTypes.set(t, n);
      for (let i = 0; i < o; i++)
        n.workerTasks.set(i, new I({
          taskName: t,
          workerId: i,
          workerConfig: e.workerConfig,
          verbose: this.verbose
        }));
    }
    return r;
  }
  /**
   * Provides initialization configuration and transferable objects.
   *
   * @param {string} taskTypeName The name of the registered task type.
   * @param {WorkerMessageDef} [def] Initialization instructions.
   */
  async initTaskType(e, t) {
    const r = [], o = this.taskTypes.get(e);
    if (o) {
      this.workerExecutionPlans.set(e, []);
      for (const n of o.workerTasks.values())
        n.connectWorker(), t && r.push(n.initWorker({
          message: t.message,
          transferables: t.transferables,
          copyTransferables: t.copyTransferables === !0
        }));
    } else
      r.push(Promise.reject());
    return r.length === 0 && r.push(Promise.resolve()), Promise.all(r);
  }
  /**
   * Queues a new task of the given type. Task will not execute until initialization completes.
   *
   * @param {string} taskTypeName The name of the registered task type.
   * @param {WorkerExecutionDef} Defines all the information needed to execute the worker task.
   * @return {Promise}
   */
  async enqueueForExecution(e, t) {
    const r = t, o = new Promise((i, l) => {
      r.promiseFunctions = {
        resolve: i,
        reject: l
      };
    }), n = this.workerExecutionPlans.get(e);
    return n == null || n.push(r), this.depleteWorkerExecutionPlans(e), o;
  }
  async depleteWorkerExecutionPlans(e) {
    var o, n;
    const t = this.workerExecutionPlans.get(e);
    if ((t == null ? void 0 : t.length) === 0) {
      this.verbose && console.log(`No more WorkerExecutionPlans in the queue for: ${e}`);
      return;
    }
    const r = t == null ? void 0 : t.shift();
    if (r) {
      const i = this.taskTypes.get(e), l = this.getUnusedWorkerTask(i);
      if (l)
        try {
          const p = await l.executeWorker(r);
          (o = r.promiseFunctions) == null || o.resolve(p), this.depleteWorkerExecutionPlans(e);
        } catch (p) {
          (n = r.promiseFunctions) == null || n.reject(new Error("Execution error: " + p)), this.depleteWorkerExecutionPlans(e);
        }
      else
        t == null || t.unshift(r);
    }
  }
  getUnusedWorkerTask(e) {
    if (e) {
      for (const t of e.workerTasks.values())
        if (!t.isWorkerExecuting())
          return t;
    }
  }
  /**
   * Destroys all workers and associated resources.
   * @return {WorkerTaskDirector}
   */
  dispose() {
    for (const e of this.taskTypes.values())
      for (const t of e.workerTasks.values())
        t.dispose();
    return this;
  }
};
a(f, "DEFAULT_MAX_PARALLEL_EXECUTIONS", 4);
let k = f;
class P {
  constructor(e) {
    a(this, "$type", "RawPayload");
    a(this, "message", {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      raw: {}
    });
    e && (this.message.raw = e);
  }
}
const C = (s, e, t) => {
  for (const r of s) {
    const o = t ? r.slice(0) : r, n = o.buffer;
    n ? e.push(n) : e.push(o);
  }
}, F = (s, e, t) => {
  if (e)
    for (const [r, o] of Object.entries(e)) {
      const n = "set" + r.substring(0, 1).toLocaleUpperCase() + r.substring(1);
      Object.prototype.hasOwnProperty.call(s, n) && typeof s[n] == "function" ? s[n] = o : (Object.prototype.hasOwnProperty.call(s, r) || t) && (s[r] = o);
    }
}, D = (s) => {
  const e = new Blob(s, { type: "application/javascript" });
  return window.URL.createObjectURL(e);
}, K = async (s, e) => {
  const t = new MessageChannel(), r = [], o = new P({
    port: t.port1
  });
  r.push(s.sentMessage({
    message: c.fromPayload(o, w.INIT_CHANNEL),
    transferables: [t.port1],
    awaitAnswer: !0,
    answer: u.INIT_CHANNEL_COMPLETE
  }));
  const n = new P({
    port: t.port2
  });
  return r.push(e.sentMessage({
    message: c.fromPayload(n, w.INIT_CHANNEL),
    transferables: [t.port2],
    awaitAnswer: !0,
    answer: u.INIT_CHANNEL_COMPLETE
  })), Promise.all(r);
};
class T {
  constructor() {
    a(this, "$type", "DataPayload");
    a(this, "message", {
      buffers: /* @__PURE__ */ new Map(),
      params: {}
    });
    a(this, "progress", 0);
  }
}
class N {
  pack(e, t, r) {
    var n;
    const o = e;
    return o.message.buffers && C((n = o.message.buffers) == null ? void 0 : n.values(), t, r), t;
  }
  unpack(e, t) {
    const r = e, o = Object.assign(new T(), e);
    if (r.message.buffers)
      for (const [n, i] of r.message.buffers.entries())
        o.message.buffers && o.message.buffers.set(n, t ? i.slice(0) : i);
    return o;
  }
}
d.handler.set("DataPayload", new N());
class E {
  constructor(e) {
    a(this, "$type", "OffscreenPayload");
    a(this, "message");
    this.message = e;
  }
}
const b = (s) => {
  s.preventDefault();
}, x = [
  "ctrlKey",
  "metaKey",
  "shiftKey",
  "button",
  "pointerType",
  "pointerId",
  "clientX",
  "clientY",
  "pageX",
  "pageY"
], A = (s, e, t) => {
  const r = g(s, t);
  e.sentMessage({
    message: c.fromPayload(r, "proxyEvent")
  });
}, M = [
  "deltaX",
  "deltaY"
], O = (s, e, t) => {
  const r = g(s, t);
  e.sentMessage({
    message: c.fromPayload(r, "proxyEvent")
  });
}, _ = [
  "ctrlKey",
  "altKey",
  "metaKey",
  "shiftKey",
  "code"
], R = [
  "ArrowLeft",
  "ArrowUp",
  "ArrowRight",
  "ArrowDown",
  "KeyW",
  "KeyA",
  "KeyS",
  "KeyD"
], L = (s, e, t, r) => {
  const { code: o } = s;
  if (r != null && r.includes(o)) {
    const n = g(s, t);
    e.sentMessage({
      message: c.fromPayload(n, "proxyEvent")
    });
  }
}, g = (s, e) => {
  const t = {
    type: s.type
  };
  if (e)
    for (const r of e)
      t[r] = s[r];
  return new E({
    event: t
  });
}, U = (s, e) => {
  const t = [], r = s;
  for (let n = 0; n < r.touches.length; ++n) {
    const i = r.touches[n];
    t.push({
      pageX: i.pageX,
      pageY: i.pageY
    });
  }
  const o = new E({
    event: {
      type: s.type,
      touches: t
    }
  });
  e.sentMessage({
    message: c.fromPayload(o, h.PROXY_EVENT)
  });
}, W = () => {
  const s = /* @__PURE__ */ new Map(), e = {
    handler: b
  }, t = {
    handler: A,
    properties: x
  }, r = {
    handler: O,
    properties: M,
    passive: !0
  }, o = {
    handler: L,
    properties: _,
    positiveList: R
  }, n = {
    handler: U,
    passive: !0
  };
  return s.set("contextmenu", e), s.set("mousedown", t), s.set("mousemove", t), s.set("mouseup", t), s.set("pointerdown", t), s.set("pointermove", t), s.set("pointerup", t), s.set("wheel", r), s.set("keydown", o), s.set("touchstart", n), s.set("touchmove", n), s.set("touchend", n), s;
}, Y = async (s, e, t) => {
  e.focus(), await s.sentMessage({
    message: c.fromPayload(new E({}), h.PROXY_START),
    awaitAnswer: !0,
    answer: m.PROXY_START_COMPLETE
  });
  for (const [r, o] of t.entries())
    r.startsWith("key") ? window.addEventListener(r, (n) => {
      o.handler(n, s, o.properties, o.positiveList);
    }, o.passive === !0 ? { passive: !0 } : void 0) : e.addEventListener(r, (n) => {
      o.handler(n, s, o.properties);
    }, o.passive === !0 ? { passive: !0 } : void 0);
}, X = (s, e) => {
  const t = new E({
    width: e.offsetWidth,
    height: e.offsetHeight,
    pixelRatio: window.devicePixelRatio
  });
  s.sentMessage({
    message: c.fromPayload(t, h.RESIZE)
  });
}, V = (s, e) => {
  window.addEventListener("resize", () => X(s, e), !1);
}, z = (s) => s ? s.message.drawingSurface : void 0, B = async (s, e) => {
  const t = e.transferControlToOffscreen(), r = new E({
    drawingSurface: t,
    width: e.clientWidth,
    height: e.clientHeight,
    pixelRatio: window.devicePixelRatio
  });
  await s.sentMessage({
    message: c.fromPayload(r, h.INIT_OFFSCREEN_CANVAS),
    transferables: [t],
    awaitAnswer: !0,
    answer: m.INIT_OFFSCREEN_CANVAS_COMPLETE
  });
}, Z = (s, e, t) => (s.width = s.height * (e / t), s.width);
export {
  R as AllowedKeyProperties,
  T as DataPayload,
  N as DataPayloadHandler,
  $ as InterComPortHandler,
  _ as KeydownEventProperties,
  x as MouseEventProperties,
  E as OffscreenPayload,
  h as OffscreenWorkerCommandRequest,
  m as OffscreenWorkerCommandResponse,
  d as PayloadRegister,
  P as RawPayload,
  M as WheelEventProperties,
  I as WorkerTask,
  w as WorkerTaskCommandRequest,
  u as WorkerTaskCommandResponse,
  k as WorkerTaskDirector,
  c as WorkerTaskMessage,
  F as applyProperties,
  W as buildDefaultEventHandlingInstructions,
  H as comRouting,
  D as createWorkerBlob,
  g as extractProperties,
  C as fillTransferables,
  z as getOffscreenCanvas,
  L as handleFilteredKeydownEvent,
  A as handleMouseEvent,
  b as handlePreventDefault,
  U as handleTouchEvent,
  O as handleWheelEvent,
  K as initChannel,
  B as initOffscreenCanvas,
  Z as recalcAspectRatio,
  Y as registerCanvas,
  V as registerResizeHandler,
  X as sentResize
};
