{"version":3,"file":"index.module.js","sources":["../src/materials/MaterialBase.js","../src/materials/fullscreen/BlendMaterial.js","../src/shader/rand/sobol.glsl.js","../src/utils/SobolNumberMapGenerator.js","../src/core/PathTracingRenderer.js","../src/core/QuiltPathTracingRenderer.js","../src/utils/GeometryPreparationUtils.js","../src/core/DynamicPathTracingSceneGenerator.js","../src/core/PathTracingSceneGenerator.js","../src/core/MaterialReducer.js","../src/objects/PhysicalCamera.js","../src/objects/EquirectCamera.js","../src/objects/PhysicalSpotLight.js","../src/objects/ShapedAreaLight.js","../src/textures/ProceduralEquirectTexture.js","../src/textures/GradientEquirectTexture.js","../src/uniforms/utils.js","../src/uniforms/MaterialsTexture.js","../src/uniforms/RenderTarget2DArray.js","../src/utils/TextureUtils.js","../src/uniforms/EquirectHdrInfoUniform.js","../src/uniforms/PhysicalCameraUniform.js","../src/uniforms/LightsInfoUniformStruct.js","../src/utils/IESLoader.js","../src/uniforms/IESProfilesTexture.js","../src/shader/common/utils.glsl.js","../src/utils/BlurredEnvMapGenerator.js","../src/materials/fullscreen/DenoiseMaterial.js","../src/materials/fullscreen/GradientMapMaterial.js","../src/materials/debug/GraphMaterial.js","../src/uniforms/FloatAttributeTextureArray.js","../src/uniforms/AttributesTextureArray.js","../src/shader/structs/cameraStruct.glsl.js","../src/shader/structs/equirectStruct.glsl.js","../src/shader/structs/lightsStruct.glsl.js","../src/shader/structs/materialStruct.glsl.js","../src/shader/structs/fogMaterialBvh.glsl.js","../src/shader/bsdf/ggx.glsl.js","../src/shader/bsdf/sheen.glsl.js","../src/shader/bsdf/iridescence.glsl.js","../src/shader/bsdf/bsdfSampling.glsl.js","../src/shader/bsdf/fog.glsl.js","../src/shader/sampling/equirectSampling.glsl.js","../src/shader/sampling/lightSampling.glsl.js","../src/shader/sampling/shapeSampling.glsl.js","../src/shader/common/intersectShapes.glsl.js","../src/shader/common/math.glsl.js","../src/shader/common/fresnel.glsl.js","../src/shader/common/arraySamplerTexelFetch.glsl.js","../src/shader/rand/pcg.glsl.js","../src/materials/pathtracing/glsl/renderStructs.glsl.js","../src/materials/pathtracing/glsl/cameraUtils.glsl.js","../src/materials/pathtracing/glsl/attenuateHit.glsl.js","../src/materials/pathtracing/glsl/traceScene.glsl.js","../src/materials/pathtracing/glsl/getSurfaceRecord.glsl.js","../src/materials/pathtracing/glsl/directLightContribution.glsl.js","../src/shader/rand/stratifiedTexture.glsl.js","../src/uniforms/stratified/StratifiedSampler.js","../src/uniforms/stratified/StratifiedSamplerCombined.js","../src/uniforms/StratifiedSamplesTexture.js","../src/textures/blueNoise/utils.js","../src/textures/blueNoise/BlueNoiseSamples.js","../src/textures/blueNoise/BlueNoiseGenerator.js","../src/textures/BlueNoiseTexture.js","../src/materials/pathtracing/PhysicalPathTracingMaterial.js","../src/materials/surface/FogVolumeMaterial.js","../src/detectors/PrecisionMaterial.js","../src/detectors/PrecisionDetector.js","../src/detectors/MaterialCompileDetector.js","../src/detectors/CompatibilityDetector.js","../src/index.js"],"sourcesContent":["import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { NoBlending } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class BlendMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\ttarget1: { value: null },\n\t\t\t\ttarget2: { value: null },\n\t\t\t\topacity: { value: 1.0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","// References\n// - https://jcgt.org/published/0009/04/01/\n// - Code from https://www.shadertoy.com/view/WtGyDm\n\n// functions to generate multi-dimensions variables of the same functions\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\nfunction generateSobolFunctionVariants( dim = 1 ) {\n\n\tlet type = 'uint';\n\tif ( dim > 1 ) {\n\n\t\ttype = 'uvec' + dim;\n\n\t}\n\n\treturn /* glsl */`\n\t\t${ type } sobolReverseBits( ${ type } x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${ type } sobolHashCombine( uint seed, ${ type } v ) {\n\n\t\t\treturn seed ^ ( v + ${ type }( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${ type } sobolLaineKarrasPermutation( ${ type } x, ${ type } seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${ type } nestedUniformScrambleBase2( ${ type } x, ${ type } seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`;\n\n}\n\nfunction generateSobolSampleFunctions( dim = 1 ) {\n\n\tlet utype = 'uint';\n\tlet vtype = 'float';\n\tlet num = '';\n\tlet components = '.r';\n\tlet combineValues = '1u';\n\tif ( dim > 1 ) {\n\n\t\tutype = 'uvec' + dim;\n\t\tvtype = 'vec' + dim;\n\t\tnum = dim + '';\n\t\tif ( dim === 2 ) {\n\n\t\t\tcomponents = '.rg';\n\t\t\tcombineValues = 'uvec2( 1u, 2u )';\n\n\t\t} else if ( dim === 3 ) {\n\n\t\t\tcomponents = '.rgb';\n\t\t\tcombineValues = 'uvec3( 1u, 2u, 3u )';\n\n\t\t} else {\n\n\t\t\tcomponents = '';\n\t\t\tcombineValues = 'uvec4( 1u, 2u, 3u, 4u )';\n\n\t\t}\n\n\t}\n\n\treturn /* glsl */`\n\n\t\t${ vtype } sobol${ num }( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${ vtype } sobol_pt = sobolGetTexturePoint( shuffled_index )${ components };\n\t\t\t${ utype } result = ${ utype }( sobol_pt * 16777216.0 );\n\n\t\t\t${ utype } seed2 = sobolHashCombine( seed, ${ combineValues } );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${ vtype }( result >> 8 );\n\n\t\t}\n\t`;\n\n}\n\nexport const sobolCommonGLSL = /* glsl */`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${ generateSobolFunctionVariants( 1 ) }\n\t${ generateSobolFunctionVariants( 2 ) }\n\t${ generateSobolFunctionVariants( 3 ) }\n\t${ generateSobolFunctionVariants( 4 ) }\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`;\n\nexport const sobolGenerationGLSL = /* glsl */`\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTEL this sobol \"direction\" is also available but we can't write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n`;\n\nexport const sobolSamplingGLSL = /* glsl */`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex = 0u;\n\tuint sobolPathIndex = 0u;\n\tuint sobolBounceIndex = 0u;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${ generateSobolSampleFunctions( 1 ) }\n\t${ generateSobolSampleFunctions( 2 ) }\n\t${ generateSobolSampleFunctions( 3 ) }\n\t${ generateSobolSampleFunctions( 4 ) }\n\n`;\n","import { FloatType, NearestFilter, NoBlending, RGBAFormat, Vector2, WebGLRenderTarget } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { sobolCommonGLSL, sobolGenerationGLSL } from '../shader/rand/sobol.glsl.js';\n\nclass SobolNumbersMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t${ sobolCommonGLSL }\n\t\t\t\t${ sobolGenerationGLSL }\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class SobolNumberMapGenerator {\n\n\tgenerate( renderer, dimensions = 256 ) {\n\n\t\tconst target = new WebGLRenderTarget( dimensions, dimensions, {\n\n\t\t\ttype: FloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tminFilter: NearestFilter,\n\t\t\tmagFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\n\t\t} );\n\n\t\tconst ogTarget = renderer.getRenderTarget();\n\t\trenderer.setRenderTarget( target );\n\n\t\tconst quad = new FullScreenQuad( new SobolNumbersMaterial() );\n\t\tquad.material.resolution.set( dimensions, dimensions );\n\t\tquad.render( renderer );\n\n\t\trenderer.setRenderTarget( ogTarget );\n\t\tquad.dispose();\n\n\t\treturn target;\n\n\t}\n\n}\n","import { RGBAFormat, FloatType, HalfFloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending, Vector4 } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { BlendMaterial } from '../materials/fullscreen/BlendMaterial.js';\nimport { SobolNumberMapGenerator } from '../utils/SobolNumberMapGenerator.js';\n\nfunction* renderTask() {\n\n\tconst {\n\t\t_renderer,\n\t\t_fsQuad,\n\t\t_blendQuad,\n\t\t_primaryTarget,\n\t\t_blendTargets,\n\t\t_sobolTarget,\n\t\t_subframe,\n\t\talpha,\n\t\tcamera,\n\t\tmaterial,\n\t} = this;\n\tconst _ogScissor = new Vector4();\n\tconst _ogViewport = new Vector4();\n\n\tconst blendMaterial = _blendQuad.material;\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\n\n\twhile ( true ) {\n\n\t\tif ( alpha ) {\n\n\t\t\tblendMaterial.opacity = this._opacityFactor / ( this._samples + 1 );\n\t\t\tmaterial.blending = NoBlending;\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = this._opacityFactor / ( this._samples + 1 );\n\t\t\tmaterial.blending = NormalBlending;\n\n\t\t}\n\n\t\tconst [ subX, subY, subW, subH ] = _subframe;\n\n\t\tconst w = _primaryTarget.width;\n\t\tconst h = _primaryTarget.height;\n\t\tmaterial.resolution.set( w * subW, h * subH );\n\t\tmaterial.sobolTexture = _sobolTarget.texture;\n\t\tmaterial.stratifiedTexture.init( 20, material.bounces + material.transmissiveBounces + 5 );\n\t\tmaterial.stratifiedTexture.next();\n\t\tmaterial.seed ++;\n\n\t\tconst tilesX = this.tiles.x || 1;\n\t\tconst tilesY = this.tiles.y || 1;\n\t\tconst totalTiles = tilesX * tilesY;\n\n\t\tconst pxSubW = Math.ceil( w * subW );\n\t\tconst pxSubH = Math.ceil( h * subH );\n\t\tconst pxSubX = Math.floor( subX * w );\n\t\tconst pxSubY = Math.floor( subY * h );\n\n\t\tconst pxTileW = Math.ceil( pxSubW / tilesX );\n\t\tconst pxTileH = Math.ceil( pxSubH / tilesY );\n\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\n\n\t\t\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\n\t\t\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\n\n\t\t\t\t// Perspective camera (default)\n\t\t\t\tlet cameraType = 0;\n\n\t\t\t\t// An orthographic projection matrix will always have the bottom right element == 1\n\t\t\t\t// And a perspective projection matrix will always have the bottom right element == 0\n\t\t\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\n\n\t\t\t\t\t// Orthographic\n\t\t\t\t\tcameraType = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( camera.isEquirectCamera ) {\n\n\t\t\t\t\t// Equirectangular\n\t\t\t\t\tcameraType = 2;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\n\n\t\t\t\t// store og state\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\n\t\t\t\tconst ogScissorTest = _renderer.getScissorTest();\n\t\t\t\t_renderer.getScissor( _ogScissor );\n\t\t\t\t_renderer.getViewport( _ogViewport );\n\n\t\t\t\tlet tx = x;\n\t\t\t\tlet ty = y;\n\t\t\t\tif ( ! this.stableTiles ) {\n\n\t\t\t\t\tconst tileIndex = ( this._currentTile ) % ( tilesX * tilesY );\n\t\t\t\t\ttx = tileIndex % tilesX;\n\t\t\t\t\tty = ~ ~ ( tileIndex / tilesX );\n\n\t\t\t\t\tthis._currentTile = tileIndex + 1;\n\n\t\t\t\t}\n\n\t\t\t\t// set the scissor and the viewport on the render target\n\t\t\t\t// note that when using the webgl renderer set viewport the device pixel ratio\n\t\t\t\t// is multiplied into the field causing some pixels to not be rendered\n\t\t\t\tconst reverseTy = tilesY - ty - 1;\n\t\t\t\t_primaryTarget.scissor.set(\n\t\t\t\t\tpxSubX + tx * pxTileW,\n\t\t\t\t\tpxSubY + reverseTy * pxTileH,\n\t\t\t\t\tMath.min( pxTileW, pxSubW - tx * pxTileW ),\n\t\t\t\t\tMath.min( pxTileH, pxSubH - reverseTy * pxTileH ),\n\t\t\t\t);\n\n\t\t\t\t_primaryTarget.viewport.set(\n\t\t\t\t\tpxSubX,\n\t\t\t\t\tpxSubY,\n\t\t\t\t\tpxSubW,\n\t\t\t\t\tpxSubH,\n\t\t\t\t);\n\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t\t\t_renderer.setScissorTest( true );\n\n\t\t\t\t_renderer.autoClear = false;\n\t\t\t\t_fsQuad.render( _renderer );\n\n\t\t\t\t// reset original renderer state\n\t\t\t\t_renderer.setViewport( _ogViewport );\n\t\t\t\t_renderer.setScissor( _ogScissor );\n\t\t\t\t_renderer.setScissorTest( ogScissorTest );\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\t\t\t\t_renderer.autoClear = ogAutoClear;\n\n\t\t\t\t// swap and blend alpha targets\n\t\t\t\tif ( alpha ) {\n\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\n\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\n\t\t\t\t\t_blendQuad.render( _renderer );\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tthis._samples += ( 1 / totalTiles );\n\n\t\t\t\t// round the samples value if we've finished the tiles\n\t\t\t\tif ( x === tilesX - 1 && y === tilesY - 1 ) {\n\n\t\t\t\t\tthis._samples = Math.round( this._samples );\n\n\t\t\t\t}\n\n\t\t\t\tyield;\n\n\t\t\t}\n\n\t\t}\n\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\n\n\t}\n\n}\n\nconst ogClearColor = new Color();\nexport class PathTracingRenderer {\n\n\tget material() {\n\n\t\treturn this._fsQuad.material;\n\n\t}\n\n\tset material( v ) {\n\n\t\tthis._fsQuad.material = v;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\n\n\t}\n\n\tset alpha( v ) {\n\n\t\tif ( this._alpha === v ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( ! v ) {\n\n\t\t\tthis._blendTargets[ 0 ].dispose();\n\t\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\t}\n\n\t\tthis._alpha = v;\n\t\tthis.reset();\n\n\t}\n\n\tget alpha() {\n\n\t\treturn this._alpha;\n\n\t}\n\n\tget samples() {\n\n\t\treturn this._samples;\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\tthis.camera = null;\n\t\tthis.tiles = new Vector2( 1, 1 );\n\n\t\tthis.stableNoise = false;\n\t\tthis.stableTiles = true;\n\n\t\tthis._samples = 0;\n\t\tthis._subframe = new Vector4( 0, 0, 1, 1 );\n\t\tthis._opacityFactor = 1.0;\n\t\tthis._renderer = renderer;\n\t\tthis._alpha = false;\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\n\t\tthis._task = null;\n\t\tthis._currentTile = 0;\n\n\t\tthis._sobolTarget = new SobolNumberMapGenerator().generate( renderer );\n\n\t\t// will be null if extension not supported\n\t\tconst floatLinearExtensionSupported = renderer.extensions.get( 'OES_texture_float_linear' );\n\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: floatLinearExtensionSupported ? FloatType : HalfFloatType,\n\t\t} );\n\t\tthis._blendTargets = [\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: floatLinearExtensionSupported ? FloatType : HalfFloatType,\n\t\t\t} ),\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: floatLinearExtensionSupported ? FloatType : HalfFloatType,\n\t\t\t} ),\n\t\t];\n\n\t}\n\n\tsetSize( w, h ) {\n\n\t\tw = Math.ceil( w );\n\t\th = Math.ceil( h );\n\n\t\tif ( this._primaryTarget.width === w && this._primaryTarget.height === h ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._primaryTarget.setSize( w, h );\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\n\t\tthis.reset();\n\n\t}\n\n\tdispose() {\n\n\t\tthis._primaryTarget.dispose();\n\t\tthis._blendTargets[ 0 ].dispose();\n\t\tthis._blendTargets[ 1 ].dispose();\n\t\tthis._sobolTarget.dispose();\n\n\t\tthis._fsQuad.dispose();\n\t\tthis._blendQuad.dispose();\n\t\tthis._task = null;\n\n\t}\n\n\treset() {\n\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.getClearColor( ogClearColor );\n\n\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\n\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\tthis._samples = 0;\n\t\tthis._task = null;\n\n\t\tif ( this.stableNoise ) {\n\n\t\t\tthis.material.seed = 0;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tif ( ! this._task ) {\n\n\t\t\tthis._task = renderTask.call( this );\n\n\t\t}\n\n\t\tthis._task.next();\n\n\t}\n\n}\n","import { PerspectiveCamera, Vector3, MathUtils, Vector2, Matrix4, Vector4 } from 'three';\nimport { PathTracingRenderer } from './PathTracingRenderer.js';\n\nfunction* _task( cb ) {\n\n\tconst {\n\t\tviewCount,\n\t\t_camera,\n\t\t_quiltUtility,\n\t\t_subframe,\n\t} = this;\n\n\tconst quiltViewInfo = {\n\t\tsubframe: _subframe,\n\t\tprojectionMatrix: _camera.projectionMatrix,\n\t\toffsetDirection: new Vector3(),\n\t};\n\n\twhile ( true ) {\n\n\t\tfor ( let i = 0; i < viewCount; i ++ ) {\n\n\t\t\t// get the camera info for the current view index\n\t\t\t_quiltUtility.near = this.camera.near;\n\t\t\t_quiltUtility.far = this.camera.far;\n\t\t\t_quiltUtility.getCameraViewInfo( i, quiltViewInfo );\n\n\t\t\t// transform offset into world frame from camera frame\n\t\t\tquiltViewInfo.offsetDirection.transformDirection( this.camera.matrixWorld );\n\n\t\t\t// adjust the render camera with the view offset\n\t\t\tthis.camera.matrixWorld.decompose(\n\t\t\t\t_camera.position,\n\t\t\t\t_camera.quaternion,\n\t\t\t\t_camera.scale,\n\t\t\t);\n\t\t\t_camera.position.addScaledVector( quiltViewInfo.offsetDirection, quiltViewInfo.offset );\n\t\t\t_camera.updateMatrixWorld();\n\n\t\t\t// get the inverse projection\n\t\t\t_camera.projectionMatrixInverse\n\t\t\t\t.copy( _camera.projectionMatrix )\n\t\t\t\t.invert();\n\n\t\t\tthis._opacityFactor = Math.floor( this._samples + 1 ) / Math.floor( this._quiltSamples + 1 );\n\n\t\t\tdo {\n\n\t\t\t\tconst ogCamera = this.camera;\n\t\t\t\tthis.camera = _camera;\n\t\t\t\tcb();\n\t\t\t\tthis.camera = ogCamera;\n\t\t\t\tyield;\n\n\t\t\t} while ( this._samples % 1 !== 0 );\n\n\t\t\tthis._quiltSamples += 1 / viewCount;\n\n\t\t}\n\n\t\tthis._quiltSamples = Math.round( this._quiltSamples );\n\n\t}\n\n}\n\n// Helper for extracting the camera projection, offset, and quilt subframe needed\n// for rendering a quilt with the provided parameters.\nclass QuiltViewUtility {\n\n\tconstructor() {\n\n\t\tthis.viewCount = 48;\n\t\tthis.quiltDimensions = new Vector2( 8, 6 );\n\t\tthis.viewCone = 35 * MathUtils.DEG2RAD;\n\t\tthis.viewFoV = 14 * MathUtils.DEG2RAD;\n\t\tthis.displayDistance = 1;\n\t\tthis.displayAspect = 0.75;\n\t\tthis.near = 0.01;\n\t\tthis.far = 10;\n\n\t}\n\n\tgetCameraViewInfo( i, target = {} ) {\n\n\t\tconst {\n\t\t\tquiltDimensions,\n\t\t\tviewCone,\n\t\t\tdisplayDistance,\n\t\t\tviewCount,\n\t\t\tviewFoV,\n\t\t\tdisplayAspect,\n\t\t\tnear,\n\t\t\tfar,\n\t\t} = this;\n\n\t\t// initialize defaults\n\t\ttarget.subframe = target.subframe || new Vector4();\n\t\ttarget.offsetDirection = target.offsetDirection || new Vector3();\n\t\ttarget.projectionMatrix\t= target.projectionMatrix || new Matrix4();\n\n\t\t// set camera offset\n\t\tconst halfWidth = Math.tan( 0.5 * viewCone ) * displayDistance;\n\t\tconst totalWidth = halfWidth * 2.0;\n\t\tconst stride = totalWidth / ( viewCount - 1 );\n\t\tconst offset = viewCount === 1 ? 0 : - halfWidth + stride * i;\n\t\ttarget.offsetDirection.set( 1.0, 0, 0 );\n\t\ttarget.offset = offset;\n\n\t\t// set the projection matrix\n\t\tconst displayHalfHeight = Math.tan( viewFoV * 0.5 ) * displayDistance;\n\t\tconst displayHalfWidth = displayAspect * displayHalfHeight;\n\t\tconst nearScale = near / displayDistance;\n\n\t\ttarget.projectionMatrix.makePerspective(\n\t\t\tnearScale * ( - displayHalfWidth - offset ), nearScale * ( displayHalfWidth - offset ),\n\t\t\tnearScale * displayHalfHeight, nearScale * - displayHalfHeight,\n\t\t\tnear, far,\n\t\t);\n\n\t\t// set the quilt subframe\n\t\tconst x = i % quiltDimensions.x;\n\t\tconst y = Math.floor( i / quiltDimensions.x );\n\n\t\tconst qw = 1 / quiltDimensions.x;\n\t\tconst qh = 1 / quiltDimensions.y;\n\t\ttarget.subframe.set( x * qw, y * qh, qw, qh );\n\n\t\treturn target;\n\n\t}\n\n\tsetFromDisplayView( viewerDistance, displayWidth, displayHeight ) {\n\n\t\tthis.displayAspect = displayWidth / displayHeight;\n\t\tthis.displayDistance = viewerDistance;\n\t\tthis.viewFoV = 2.0 * Math.atan( 0.5 * displayHeight / viewerDistance );\n\n\t}\n\n}\n\nexport class QuiltPathTracingRenderer extends PathTracingRenderer {\n\n\tget samples() {\n\n\t\treturn this._samples / this.viewCount;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\t[\n\t\t\t'quiltDimensions',\n\t\t\t'viewCount',\n\t\t\t'viewCone',\n\t\t\t'viewFoV',\n\t\t\t'displayDistance',\n\t\t\t'displayAspect',\n\t\t].forEach( member => {\n\n\t\t\tObject.defineProperty( this, member, {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tset: v => {\n\n\t\t\t\t\tthis._quiltUtility[ member ] = v;\n\n\t\t\t\t},\n\n\t\t\t\tget: () => {\n\n\t\t\t\t\treturn this._quiltUtility[ member ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\n\t\tthis._quiltUtility = new QuiltViewUtility();\n\t\tthis._quiltSamples = 0;\n\t\tthis._camera = new PerspectiveCamera();\n\t\tthis._quiltTask = null;\n\n\t}\n\n\tsetFromDisplayView( ...args ) {\n\n\t\tthis._quiltUtility.setFromDisplayView( ...args );\n\n\t}\n\n\tupdate() {\n\n\t\tthis.alpha = false;\n\t\tif ( ! this._quiltTask ) {\n\n\t\t\tthis._quiltTask = _task.call( this, () => {\n\n\t\t\t\tsuper.update();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis._quiltTask.next();\n\n\t}\n\n\treset() {\n\n\t\tsuper.reset();\n\t\tthis._quiltTask = null;\n\t\tthis._quiltSamples = 0;\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\nimport { mergeVertices } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nexport function getGroupMaterialIndicesAttribute( geometry, materials, allMaterials ) {\n\n\tconst indexAttr = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst vertCount = posAttr.count;\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\n\tlet groups = geometry.groups;\n\tif ( groups.length === 0 ) {\n\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\n\n\t}\n\n\t// use an array with the minimum precision required to store all material id references.\n\tlet materialArray;\n\tif ( allMaterials.length <= 255 ) {\n\n\t\tmaterialArray = new Uint8Array( vertCount );\n\n\t} else {\n\n\t\tmaterialArray = new Uint16Array( vertCount );\n\n\t}\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst start = group.start;\n\t\tconst count = group.count;\n\t\tconst endCount = Math.min( count, totalCount - start );\n\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\n\t\tconst materialIndex = allMaterials.indexOf( mat );\n\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\n\n\t\t\tlet index = start + j;\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindex = indexAttr.getX( index );\n\n\t\t\t}\n\n\t\t\tmaterialArray[ index ] = materialIndex;\n\n\t\t}\n\n\t}\n\n\treturn new BufferAttribute( materialArray, 1, false );\n\n}\n\nexport function setCommonAttributes( geometry, options ) {\n\n\tconst { attributes = [], normalMapRequired = false } = options;\n\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\n\n\t\tgeometry.computeVertexNormals();\n\n\t}\n\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.uv2 && ( attributes && attributes.includes( 'uv2' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv2', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\n\n\t\tif ( normalMapRequired ) {\n\n\t\t\t// computeTangents requires an index buffer\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tgeometry = mergeVertices( geometry );\n\n\t\t\t}\n\n\t\t\tgeometry.computeTangents();\n\n\t\t} else {\n\n\t\t\tconst vertCount = geometry.attributes.position.count;\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\n\n\t\t}\n\n\t}\n\n\tif ( ! geometry.attributes.color && ( attributes && attributes.includes( 'color' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tconst array = new Float32Array( vertCount * 4 );\n\t\tarray.fill( 1.0 );\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( array, 4 ) );\n\n\t}\n\n\tif ( ! geometry.index ) {\n\n\t\t// TODO: compute a typed array\n\t\tconst indexCount = geometry.attributes.position.count;\n\t\tconst array = new Array( indexCount );\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\n\n\t\t\tarray[ i ] = i;\n\n\t\t}\n\n\t\tgeometry.setIndex( array );\n\n\t}\n\n}\n","import { BufferGeometry, MeshBasicMaterial, BufferAttribute, Mesh } from 'three';\nimport { StaticGeometryGenerator, MeshBVH, SAH } from 'three-mesh-bvh';\nimport { setCommonAttributes, getGroupMaterialIndicesAttribute } from '../utils/GeometryPreparationUtils.js';\n\nconst dummyMaterial = new MeshBasicMaterial();\nexport function getDummyMesh() {\n\n\tconst emptyGeometry = new BufferGeometry();\n\temptyGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( 9 ), 3 ) );\n\treturn new Mesh( emptyGeometry, dummyMaterial );\n\n}\n\nexport class DynamicPathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( objects ) {\n\n\t\t// ensure the objects is an array\n\t\tif ( ! Array.isArray( objects ) ) {\n\n\t\t\tobjects = [ objects ];\n\n\t\t}\n\n\t\t// use a dummy object for a fallback\n\t\tconst finalObjects = [ ...objects ];\n\t\tif ( finalObjects.length === 0 ) {\n\n\t\t\tfinalObjects.push( getDummyMesh() );\n\n\t\t}\n\n\t\t// options\n\t\tthis.bvhOptions = {};\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'color', 'uv', 'uv2' ];\n\n\t\t// state\n\t\tthis.objects = finalObjects;\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.lights = [];\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.objects );\n\n\t}\n\n\treset() {\n\n\t\tthis.bvh = null;\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.lights = [];\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.objects );\n\n\t}\n\n\tdispose() {}\n\n\tprepScene() {\n\n\t\tif ( this.bvh !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { objects, staticGeometryGenerator, geometry, lights, attributes } = this;\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tobjects[ i ].traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst normalMapRequired = ! ! c.material.normalMap;\n\t\t\t\t\tsetCommonAttributes( c.geometry, { attributes, normalMapRequired } );\n\n\t\t\t\t} else if (\n\t\t\t\t\tc.isRectAreaLight ||\n\t\t\t\t\tc.isSpotLight ||\n\t\t\t\t\tc.isPointLight ||\n\t\t\t\t\tc.isDirectionalLight\n\t\t\t\t) {\n\n\t\t\t\t\tlights.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst textureSet = new Set();\n\t\tconst materials = staticGeometryGenerator.getMaterials();\n\t\tmaterials.forEach( material => {\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\ttextureSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tstaticGeometryGenerator.attributes = attributes;\n\t\tstaticGeometryGenerator.generate( geometry );\n\n\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, materials, materials );\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\t\tgeometry.clearGroups();\n\n\t\tthis.materials = materials;\n\t\tthis.textures = Array.from( textureSet );\n\n\t}\n\n\tgenerate() {\n\n\t\tconst { objects, staticGeometryGenerator, geometry, bvhOptions } = this;\n\t\tif ( this.bvh === null ) {\n\n\t\t\tthis.prepScene();\n\t\t\tthis.bvh = new MeshBVH( geometry, { strategy: SAH, maxLeafTris: 1, ...bvhOptions } );\n\n\t\t\treturn {\n\t\t\t\tlights: this.lights,\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tobjects,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst { bvh } = this;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\t\t\tbvh.refit();\n\t\t\treturn {\n\t\t\t\tlights: this.lights,\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tobjects,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\n}\n","import { DynamicPathTracingSceneGenerator } from './DynamicPathTracingSceneGenerator.js';\n\nexport class PathTracingSceneGenerator {\n\n\tgenerate( scene, options = {} ) {\n\n\t\t// ensure scene transforms are up to date\n\t\t// TODO: remove this?\n\t\tif ( Array.isArray( scene ) ) {\n\n\t\t\tscene.forEach( s => s.updateMatrixWorld( true ) );\n\n\t\t} else {\n\n\t\t\tscene.updateMatrixWorld( true );\n\n\t\t}\n\n\t\tconst generator = new DynamicPathTracingSceneGenerator( scene );\n\t\tgenerator.bvhOptions = options;\n\t\treturn generator.generate();\n\n\t}\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import { PerspectiveCamera } from 'three';\n\nexport class PhysicalCamera extends PerspectiveCamera {\n\n\tset bokehSize( size ) {\n\n\t\tthis.fStop = this.getFocalLength() / size;\n\n\t}\n\n\tget bokehSize() {\n\n\t\treturn this.getFocalLength() / this.fStop;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.fStop = 1.4;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 25;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fStop = source.fStop;\n\t\tthis.apertureBlades = source.apertureBlades;\n\t\tthis.apertureRotation = source.apertureRotation;\n\t\tthis.focusDistance = source.focusDistance;\n\t\tthis.anamorphicRatio = source.anamorphicRatio;\n\n\t\treturn this;\n\n\t}\n\n}\n","import { Camera } from 'three';\n\nexport class EquirectCamera extends Camera {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isEquirectCamera = true;\n\n\t}\n\n}\n","import { SpotLight } from 'three';\n\nexport class PhysicalSpotLight extends SpotLight {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.iesTexture = null;\n\t\tthis.radius = 0;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesTexture = source.iesTexture;\n\t\tthis.radius = source.radius;\n\n\t\treturn this;\n\n\t}\n\n}\n","import { RectAreaLight } from 'three';\n\nexport class ShapedAreaLight extends RectAreaLight {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isCircular = false;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.isCircular = source.isCircular;\n\n\t\treturn this;\n\n\t}\n\n}\n","import {\n\tClampToEdgeWrapping,\n\tColor,\n\tDataTexture,\n\tEquirectangularReflectionMapping,\n\tLinearFilter,\n\tRepeatWrapping,\n\tRGBAFormat,\n\tSpherical,\n\tVector2,\n\tFloatType\n} from 'three';\n\nconst _uv = new Vector2();\nconst _coord = new Vector2();\nconst _polar = new Spherical();\nconst _color = new Color();\nexport class ProceduralEquirectTexture extends DataTexture {\n\n\tconstructor( width = 512, height = 512 ) {\n\n\t\tsuper(\n\t\t\tnew Float32Array( width * height * 4 ),\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\n\t\t);\n\n\t\tthis.generationCallback = null;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t\tconst { data, width, height } = this.image;\n\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\t_coord.set( width, height );\n\n\t\t\t\t_uv.set( x / width, y / height );\n\t\t\t\t_uv.x -= 0.5;\n\t\t\t\t_uv.y = 1.0 - _uv.y;\n\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\n\t\t\t\t_polar.radius = 1.0;\n\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst i4 = 4 * i;\n\t\t\t\tdata[ i4 + 0 ] = ( _color.r );\n\t\t\t\tdata[ i4 + 1 ] = ( _color.g );\n\t\t\t\tdata[ i4 + 2 ] = ( _color.b );\n\t\t\t\tdata[ i4 + 3 ] = ( 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.generationCallback = other.generationCallback;\n\t\treturn this;\n\n\t}\n\n}\n","import { Color, Vector3 } from 'three';\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\n\nconst _direction = new Vector3();\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\n\n\tconstructor( resolution = 512 ) {\n\n\t\tsuper( resolution, resolution );\n\n\t\tthis.topColor = new Color().set( 0xffffff );\n\t\tthis.bottomColor = new Color().set( 0x000000 );\n\t\tthis.exponent = 2;\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\n\n\t\t\t_direction.setFromSpherical( polar );\n\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\n\n\t\t};\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\n\t\tthis.topColor.copy( other.topColor );\n\t\tthis.bottomColor.copy( other.bottomColor );\n\t\treturn this;\n\n\t}\n\n}\n","// we must hash the texture to determine uniqueness using the encoding, as well, because the\n// when rendering each texture to the texture array they must have a consistent color space.\nexport function getTextureHash( t ) {\n\n\treturn `${ t.source.uuid }:${ t.colorSpace }`;\n\n}\n\n// reduce the set of textures to just those with a unique source while retaining\n// the order of the textures.\nexport function reduceTexturesToUniqueSources( textures ) {\n\n\tconst sourceSet = new Set();\n\tconst result = [];\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\tconst tex = textures[ i ];\n\t\tconst hash = getTextureHash( tex );\n\t\tif ( ! sourceSet.has( hash ) ) {\n\n\t\t\tsourceSet.add( hash );\n\t\t\tresult.push( tex );\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, NearestFilter } from 'three';\nimport { reduceTexturesToUniqueSources, getTextureHash } from './utils.js';\n\nconst MATERIAL_PIXELS = 45;\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\n\nconst MATTE_OFFSET = 14 * 4 + 0; // s14.r\nconst SHADOW_OFFSET = 14 * 4 + 1; // s14.g\n\nclass MaterialFeatures {\n\n\tconstructor() {\n\n\t\tthis._features = {};\n\n\t}\n\n\tisUsed( feature ) {\n\n\t\treturn feature in this._features;\n\n\t}\n\n\tsetUsed( feature, used = true ) {\n\n\t\tif ( used === false ) {\n\n\t\t\tdelete this._features[ feature ];\n\n\t\t} else {\n\n\t\t\tthis._features[ feature ] = true;\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis._features = {};\n\n\t}\n\n}\n\nexport class MaterialsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.threeCompatibilityTransforms = false;\n\t\tthis.features = new MaterialFeatures();\n\n\t}\n\n\tsetCastShadow( materialIndex, cast ) {\n\n\t\t// invert the shadow value so we default to \"true\" when initializing a material\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + SHADOW_OFFSET;\n\t\tarray[ index ] = ! cast ? 1 : 0;\n\n\t}\n\n\tgetCastShadow( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + SHADOW_OFFSET;\n\t\treturn ! Boolean( array[ index ] );\n\n\t}\n\n\tsetMatte( materialIndex, matte ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + MATTE_OFFSET;\n\t\tarray[ index ] = matte ? 1 : 0;\n\n\t}\n\n\tgetMatte( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + MATTE_OFFSET;\n\t\treturn Boolean( array[ index ] );\n\n\t}\n\n\tupdateFrom( materials, textures ) {\n\n\t\tfunction getTexture( material, key, def = - 1 ) {\n\n\t\t\tif ( key in material && material[ key ] ) {\n\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\n\t\t\t\treturn uniqueTextureLookup[ hash ];\n\n\t\t\t} else {\n\n\t\t\t\treturn def;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getField( material, key, def ) {\n\n\t\t\treturn key in material ? material[ key ] : def;\n\n\t\t}\n\n\t\tfunction getUVTransformTexture( material ) {\n\n\t\t\t// https://github.com/mrdoob/three.js/blob/f3a832e637c98a404c64dae8174625958455e038/src/renderers/webgl/WebGLMaterials.js#L204-L306\n\t\t\t// https://threejs.org/docs/#api/en/textures/Texture.offset\n\t\t\t// fallback order of textures to use as a common uv transform\n\t\t\treturn material.map ||\n\t\t\t\tmaterial.specularMap ||\n\t\t\t\tmaterial.displacementMap ||\n\t\t\t\tmaterial.normalMap ||\n\t\t\t\tmaterial.bumpMap ||\n\t\t\t\tmaterial.roughnessMap ||\n\t\t\t\tmaterial.metalnessMap ||\n\t\t\t\tmaterial.alphaMap ||\n\t\t\t\tmaterial.emissiveMap ||\n\t\t\t\tmaterial.clearcoatMap ||\n\t\t\t\tmaterial.clearcoatNormalMap ||\n\t\t\t\tmaterial.clearcoatRoughnessMap ||\n\t\t\t\tmaterial.iridescenceMap ||\n\t\t\t\tmaterial.iridescenceThicknessMap ||\n\t\t\t\tmaterial.specularIntensityMap ||\n\t\t\t\tmaterial.specularColorMap ||\n\t\t\t\tmaterial.transmissionMap ||\n\t\t\t\tmaterial.thicknessMap ||\n\t\t\t\tmaterial.sheenColorMap ||\n\t\t\t\tmaterial.sheenRoughnessMap ||\n\t\t\t\tnull;\n\n\t\t}\n\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\n\n\t\t\tlet texture;\n\t\t\tif ( threeCompatibilityTransforms ) {\n\n\t\t\t\ttexture = getUVTransformTexture( material );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\n\n\t\t\t}\n\n\t\t\t// check if texture exists\n\t\t\tif ( texture ) {\n\n\t\t\t\tconst elements = texture.matrix.elements;\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\t// first row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\n\t\t\t\ti ++;\n\n\t\t\t\t// second row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn 8;\n\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) ) || 1;\n\t\tconst { threeCompatibilityTransforms, image, features } = this;\n\n\t\t// get the list of textures with unique sources\n\t\tconst uniqueTextures = reduceTexturesToUniqueSources( textures );\n\t\tconst uniqueTextureLookup = {};\n\t\tfor ( let i = 0, l = uniqueTextures.length; i < l; i ++ ) {\n\n\t\t\tuniqueTextureLookup[ getTextureHash( uniqueTextures[ i ] ) ] = i;\n\n\t\t}\n\n\t\tif ( image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\n\t\t\timage.width = dimension;\n\t\t\timage.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = image.data;\n\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n\t\t// can't encode texture ids that way.\n\t\t// const intArray = new Int32Array( floatArray.buffer );\n\n\t\tfeatures.reset();\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tconst m = materials[ i ];\n\n\t\t\tif ( m.isFogVolumeMaterial ) {\n\n\t\t\t\tfeatures.setUsed( 'FOG' );\n\n\t\t\t\tfor ( let j = 0; j < MATERIAL_STRIDE; j ++ ) {\n\n\t\t\t\t\tfloatArray[ index + j ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// sample 0 .rgb\n\t\t\t\tfloatArray[ index + 0 * 4 + 0 ] = m.color.r;\n\t\t\t\tfloatArray[ index + 0 * 4 + 1 ] = m.color.g;\n\t\t\t\tfloatArray[ index + 0 * 4 + 2 ] = m.color.b;\n\n\t\t\t\t// sample 2 .a\n\t\t\t\tfloatArray[ index + 2 * 4 + 3 ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t\t// sample 3 .rgb\n\t\t\t\tfloatArray[ index + 3 * 4 + 0 ] = m.emissive.r;\n\t\t\t\tfloatArray[ index + 3 * 4 + 1 ] = m.emissive.g;\n\t\t\t\tfloatArray[ index + 3 * 4 + 2 ] = m.emissive.b;\n\n\t\t\t\t// sample 13 .g\n\t\t\t\t// reusing opacity field\n\t\t\t\tfloatArray[ index + 13 * 4 + 1 ] = m.density;\n\n\t\t\t\t// side\n\t\t\t\tfloatArray[ index + 13 * 4 + 3 ] = 0.0;\n\n\t\t\t\t// sample 14 .b\n\t\t\t\tfloatArray[ index + 14 * 4 + 2 ] = 1 << 2;\n\n\t\t\t\tindex += MATERIAL_STRIDE;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// sample 0\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = m.color.r;\n\t\t\tfloatArray[ index ++ ] = m.color.g;\n\t\t\tfloatArray[ index ++ ] = m.color.b;\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\n\n\t\t\t// sample 1\n\t\t\t// metalness & roughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\n\n\t\t\t// sample 2\n\t\t\t// transmission & emissiveIntensity\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t// sample 3\n\t\t\t// emission\n\t\t\tif ( 'emissive' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\n\n\t\t\t// sample 4\n\t\t\t// normals\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\n\t\t\tif ( 'normalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\n\n \t\t\t} else {\n\n \t\t\t\tfloatArray[ index ++ ] = 1;\n \t\t\t\tfloatArray[ index ++ ] = 1;\n\n \t\t\t}\n\n\t\t\t// clearcoat\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\n\n\t\t\t// sample 6\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\n\t\t\t}\n\n\t\t\tindex ++;\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheen', 0.0 );\n\n\t\t\t// sample 7\n\t\t\t// sheen\n\t\t\tif ( 'sheenColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\n\n\t\t\t// sample 8\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\n\n\t\t\t// iridescence\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\n\n\t\t\t// sample 9\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\n\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\n\n\t\t\t// sample 10\n\t\t\t// specular color\n\t\t\tif ( 'specularColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\n\n\t\t\t// sample 11\n\t\t\t// specular intensity\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\n\n\t\t\t// isThinFilm\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\n\t\t\tindex ++;\n\n\t\t\t// sample 12\n\t\t\tif ( 'attenuationColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\n\n\t\t\t// sample 13\n\t\t\t// alphaMap\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\n\n\t\t\t// side & matte\n\t\t\tfloatArray[ index ++ ] = m.opacity;\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\n\n\t\t\t\tfloatArray[ index ++ ] = 0;\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( m.side ) {\n\n\t\t\t\tcase FrontSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BackSide:\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DoubleSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sample 14\n\t\t\tindex ++; // matte\n\t\t\tindex ++; // shadow\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ); // vertexColors & flatShading\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\n\n\t\t\t// map transform 15\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\n\n\t\t\t// metalnessMap transform 17\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\n\n\t\t\t// roughnessMap transform 19\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\n\n\t\t\t// transmissionMap transform 21\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\n\n\t\t\t// emissiveMap transform 22\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\n\n\t\t\t// normalMap transform 25\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\n\n\t\t\t// clearcoatMap transform 27\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\n\n\t\t\t// clearcoatNormalMap transform 29\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\n\n\t\t\t// clearcoatRoughnessMap transform 31\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\n\n\t\t\t// sheenColorMap transform 33\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\n\n\t\t\t// sheenRoughnessMap transform 35\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\n\n\t\t\t// iridescenceMap transform 37\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\n\n\t\t\t// iridescenceThicknessMap transform 39\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\n\n\t\t\t// specularColorMap transform 41\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\n\n\t\t\t// specularIntensityMap transform 43\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n","import {\n\tWebGLArrayRenderTarget,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tColor,\n\tRepeatWrapping,\n\tLinearFilter,\n\tNoToneMapping,\n\tShaderMaterial,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { reduceTexturesToUniqueSources } from './utils.js';\n\nconst prevColor = new Color();\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = UnsignedByteType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = RepeatWrapping;\n\t\ttex.wrapT = RepeatWrapping;\n\t\ttex.setTextures = ( ...args ) => {\n\n\t\t\tthis.setTextures( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new CopyMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t}\n\n\tsetTextures( renderer, width, height, textures ) {\n\n\t\t// get the list of textures with unique sources\n\t\tconst uniqueTextures = reduceTexturesToUniqueSources( textures );\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\n\t\tconst depth = uniqueTextures.length || 1;\n\t\tthis.setSize( width, height, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = uniqueTextures[ i ];\n\t\t\tif ( texture ) {\n\n\t\t\t\t// revert to default texture transform before rendering\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t\ttexture.matrix.identity();\n\n\t\t\t\tfsQuad.material.map = texture;\n\n\t\t\t\trenderer.setRenderTarget( this, i );\n\t\t\t\tfsQuad.render( renderer );\n\n\t\t\t\t// restore custom texture transform\n\t\t\t\ttexture.updateMatrix();\n\t\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n\nclass CopyMaterial extends ShaderMaterial {\n\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t}\n\n\n}\n","import { DataUtils } from 'three';\n\n\nexport function toHalfFloatArray( f32Array ) {\n\n\tconst f16Array = new Uint16Array( f32Array.length );\n\tfor ( let i = 0, n = f32Array.length; i < n; ++ i ) {\n\n\t\tf16Array[ i ] = DataUtils.toHalfFloat( f32Array[ i ] );\n\n\t}\n\n\treturn f16Array;\n\n}\n","import { DataTexture, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping, RGBAFormat, FloatType, ClampToEdgeWrapping } from 'three';\nimport { toHalfFloatArray } from '../utils/TextureUtils.js';\n\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\n\n\tlet lower = offset;\n\tlet upper = offset + count - 1;\n\n\twhile ( lower < upper ) {\n\n\t\t// calculate the midpoint for this iteration using a bitwise shift right operator to save 1 floating point multiplication\n\t\t// and 1 truncation from the double tilde operator to improve performance\n\t\t// this results in much better performance over using standard \"~ ~ ( (lower + upper) ) / 2\" to calculate the midpoint\n\t\tconst mid = ( lower + upper ) >> 1;\n\n\t\t// check if the middle array value is above or below the target and shift\n\t\t// which half of the array we're looking at\n\t\tif ( array[ mid ] < targetValue ) {\n\n\t\t\tlower = mid + 1;\n\n\t\t} else {\n\n\t\t\tupper = mid;\n\n\t\t}\n\n\t}\n\n\treturn lower - offset;\n\n}\n\nfunction colorToLuminance( r, g, b ) {\n\n\t// https://en.wikipedia.org/wiki/Relative_luminance\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\n}\n\n// ensures the data is all floating point values and flipY is false\nfunction preprocessEnvMap( envMap, targetType = HalfFloatType ) {\n\n\tconst map = envMap.clone();\n\tmap.source = new Source( { ...map.image } );\n\tconst { width, height, data } = map.image;\n\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\n\tlet newData = data;\n\tif ( map.type !== targetType ) {\n\n\t\tif ( targetType === HalfFloatType ) {\n\n\t\t\tnewData = new Uint16Array( data.length );\n\n\t\t} else {\n\n\t\t\tnewData = new Float32Array( data.length );\n\n\t\t}\n\n\t\tlet maxIntValue;\n\t\tif ( data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array ) {\n\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT - 1 ) - 1;\n\n\t\t} else {\n\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT ) - 1;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\tlet v = data[ i ];\n\t\t\tif ( map.type === HalfFloatType ) {\n\n\t\t\t\tv = DataUtils.fromHalfFloat( data[ i ] );\n\n\t\t\t}\n\n\t\t\tif ( map.type !== FloatType && map.type !== HalfFloatType ) {\n\n\t\t\t\tv /= maxIntValue;\n\n\t\t\t}\n\n\t\t\tif ( targetType === HalfFloatType ) {\n\n\t\t\t\tnewData[ i ] = DataUtils.toHalfFloat( v );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.image.data = newData;\n\t\tmap.type = targetType;\n\n\t}\n\n\t// remove any y flipping for cdf computation\n\tif ( map.flipY ) {\n\n\t\tconst ogData = newData;\n\t\tnewData = newData.slice();\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst newY = height - y - 1;\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\n\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.flipY = false;\n\t\tmap.image.data = newData;\n\n\t}\n\n\treturn map;\n\n}\n\nexport class EquirectHdrInfoUniform {\n\n\tconstructor() {\n\n\t\t// Default to a white texture and associated weights so we don't\n\t\t// just render black initially.\n\t\tconst whiteTex = new DataTexture( toHalfFloatArray( new Float32Array( [ 1, 1, 1, 1 ] ) ), 1, 1 );\n\t\twhiteTex.type = HalfFloatType;\n\t\twhiteTex.format = RGBAFormat;\n\t\twhiteTex.minFilter = LinearFilter;\n\t\twhiteTex.magFilter = LinearFilter;\n\t\twhiteTex.wrapS = RepeatWrapping;\n\t\twhiteTex.wrapT = RepeatWrapping;\n\t\twhiteTex.generateMipmaps = false;\n\t\twhiteTex.needsUpdate = true;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\n\t\t// used to sampling a random value to a relevant row to sample from\n\t\tconst marginalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 1 ] ) ), 1, 2 );\n\t\tmarginalWeights.type = HalfFloatType;\n\t\tmarginalWeights.format = RedFormat;\n\t\tmarginalWeights.minFilter = LinearFilter;\n\t\tmarginalWeights.magFilter = LinearFilter;\n\t\tmarginalWeights.generateMipmaps = false;\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\n\t\t// used to sampling a random value to a relevant pixel to sample from\n\t\tconst conditionalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 1, 1 ] ) ), 2, 2 );\n\t\tconditionalWeights.type = HalfFloatType;\n\t\tconditionalWeights.format = RedFormat;\n\t\tconditionalWeights.minFilter = LinearFilter;\n\t\tconditionalWeights.magFilter = LinearFilter;\n\t\tconditionalWeights.generateMipmaps = false;\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\tthis.map = whiteTex;\n\t\tthis.marginalWeights = marginalWeights;\n\t\tthis.conditionalWeights = conditionalWeights;\n\t\tthis.totalSum = 1;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.marginalWeights.dispose();\n\t\tthis.conditionalWeights.dispose();\n\t\tthis.map.dispose();\n\n\t}\n\n\tupdateFrom( hdr ) {\n\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\n\t\tconst map = preprocessEnvMap( hdr );\n\t\tmap.wrapS = RepeatWrapping;\n\t\tmap.wrapT = ClampToEdgeWrapping;\n\n\t\tconst { width, height, data } = map.image;\n\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\n\t\t// \"marginal\" = \"row relative to row sum\"\n\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\n\t\tconst pdfConditional = new Float32Array( width * height );\n\t\tconst cdfConditional = new Float32Array( width * height );\n\n\t\tconst pdfMarginal = new Float32Array( height );\n\t\tconst cdfMarginal = new Float32Array( height );\n\n\t\tlet totalSumValue = 0.0;\n\t\tlet cumulativeWeightMarginal = 0.0;\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tlet cumulativeRowWeight = 0.0;\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst r = DataUtils.fromHalfFloat( data[ 4 * i + 0 ] );\n\t\t\t\tconst g = DataUtils.fromHalfFloat( data[ 4 * i + 1 ] );\n\t\t\t\tconst b = DataUtils.fromHalfFloat( data[ 4 * i + 2 ] );\n\n\t\t\t\t// the probability of the pixel being selected in this row is the\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\n\t\t\t\tcumulativeRowWeight += weight;\n\t\t\t\ttotalSumValue += weight;\n\n\t\t\t\tpdfConditional[ i ] = weight;\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\n\n\t\t\t}\n\n\t\t\t// can happen if the row is all black\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\n\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\n\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\n\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\n\n\t\t}\n\n\t\t// can happen if the texture is all black\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\n\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\n\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute a sorted index of distributions and the probabilities along them for both\n\t\t// the marginal and conditional data. These will be used to sample with a random number\n\t\t// to retrieve a uv value to sample in the environment map.\n\t\t// These values continually increase so it's okay to interpolate between them.\n\t\tconst marginalDataArray = new Uint16Array( height );\n\t\tconst conditionalDataArray = new Uint16Array( width * height );\n\n\t\t// we add a half texel offset so we're sampling the center of the pixel\n\t\tfor ( let i = 0; i < height; i ++ ) {\n\n\t\t\tconst dist = ( i + 1 ) / height;\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\n\n\t\t\tmarginalDataArray[ i ] = DataUtils.toHalfFloat( ( row + 0.5 ) / height );\n\n\t\t}\n\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst dist = ( x + 1 ) / width;\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\n\n\t\t\t\tconditionalDataArray[ i ] = DataUtils.toHalfFloat( ( col + 0.5 ) / width );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispose();\n\n\t\tconst { marginalWeights, conditionalWeights } = this;\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\tthis.totalSum = totalSumValue;\n\t\tthis.map = map;\n\n\t}\n\n}\n","import { PhysicalCamera } from '../objects/PhysicalCamera.js';\nexport class PhysicalCameraUniform {\n\n\tconstructor() {\n\n\t\tthis.bokehSize = 0;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 10;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tupdateFrom( camera ) {\n\n\t\tif ( camera instanceof PhysicalCamera ) {\n\n\t\t\tthis.bokehSize = camera.bokehSize;\n\t\t\tthis.apertureBlades = camera.apertureBlades;\n\t\t\tthis.apertureRotation = camera.apertureRotation;\n\t\t\tthis.focusDistance = camera.focusDistance;\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\n\n\t\t} else {\n\n\t\t\tthis.bokehSize = 0;\n\t\t\tthis.apertureRotation = 0;\n\t\t\tthis.apertureBlades = 0;\n\t\t\tthis.focusDistance = 10;\n\t\t\tthis.anamorphicRatio = 1;\n\n\t\t}\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion, Matrix4, NearestFilter } from 'three';\n\nconst LIGHT_PIXELS = 6;\nconst RECT_AREA_LIGHT = 0;\nconst CIRC_AREA_LIGHT = 1;\nconst SPOT_LIGHT = 2;\nconst DIR_LIGHT = 3;\nconst POINT_LIGHT = 4;\nexport class LightsInfoUniformStruct {\n\n\tconstructor() {\n\n\t\tconst tex = new DataTexture( new Float32Array( 4 ), 1, 1 );\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = FloatType;\n\t\ttex.wrapS = ClampToEdgeWrapping;\n\t\ttex.wrapT = ClampToEdgeWrapping;\n\t\ttex.generateMipmaps = false;\n\t\ttex.minFilter = NearestFilter;\n\t\ttex.magFilter = NearestFilter;\n\n\t\tthis.tex = tex;\n\t\tthis.count = 0;\n\n\t}\n\n\tupdateFrom( lights, iesTextures = [] ) {\n\n\t\tconst tex = this.tex;\n\t\tconst pixelCount = Math.max( lights.length * LIGHT_PIXELS, 1 );\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\n\t\tif ( tex.image.width !== dimension ) {\n\n\t\t\ttex.dispose();\n\n\t\t\ttex.image.data = new Float32Array( dimension * dimension * 4 );\n\t\t\ttex.image.width = dimension;\n\t\t\ttex.image.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = tex.image.data;\n\n\t\tconst u = new Vector3();\n\t\tconst v = new Vector3();\n\t\tconst m = new Matrix4();\n\t\tconst worldQuaternion = new Quaternion();\n\t\tconst eye = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst up = new Vector3( 0, 1, 0 );\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst l = lights[ i ];\n\n\t\t\tconst baseIndex = i * LIGHT_PIXELS * 4;\n\t\t\tlet index = 0;\n\n\t\t\t// initialize to 0\n\t\t\tfor ( let p = 0; p < LIGHT_PIXELS * 4; p ++ ) {\n\n\t\t\t\tfloatArray[ baseIndex + p ] = 0;\n\n\t\t\t}\n\n\t\t\t// sample 1\n\t\t    // position\n\t\t\tl.getWorldPosition( v );\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t// type\n\t\t\tlet type = RECT_AREA_LIGHT;\n\t\t\tif ( l.isRectAreaLight && l.isCircular ) {\n\n\t\t\t\ttype = CIRC_AREA_LIGHT;\n\n\t\t\t} else if ( l.isSpotLight ) {\n\n\t\t\t\ttype = SPOT_LIGHT;\n\n\t\t\t} else if ( l.isDirectionalLight ) {\n\n\t\t\t\ttype = DIR_LIGHT;\n\n\t\t\t} else if ( l.isPointLight ) {\n\n\t\t\t\ttype = POINT_LIGHT;\n\n\t\t\t}\n\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = type;\n\n\t\t\t// sample 2\n\t\t\t// color\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.r;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.g;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.b;\n\n\t\t\t// intensity\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.intensity;\n\n\t\t\tl.getWorldQuaternion( worldQuaternion );\n\n\t\t\tif ( l.isRectAreaLight ) {\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\t// v vector\n\t\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t\t// area\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.cross( v ).length() * ( l.isCircular ? ( Math.PI / 4.0 ) : 1.0 );\n\n\t\t\t} else if ( l.isSpotLight ) {\n\n\t\t\t\tconst radius = l.radius || 0;\n\t\t\t\teye.setFromMatrixPosition( l.matrixWorld );\n\t\t\t\ttarget.setFromMatrixPosition( l.target.matrixWorld );\n\t\t\t\tm.lookAt( eye, target, up );\n\t\t\t\tworldQuaternion.setFromRotationMatrix( m );\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tu.set( 1, 0, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\t// v vector\n\t\t\t\tv.set( 0, 1, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t\t// area\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.PI * radius * radius;\n\n\t\t\t\t// sample 5\n\t\t\t\t// radius\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = radius;\n\n\t\t\t\t// decay\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\n\n\t\t\t\t// distance\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\n\n\t\t\t\t// coneCos\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle );\n\n\t\t\t\t// sample 6\n\t\t\t\t// penumbraCos\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle * ( 1 - l.penumbra ) );\n\n\t\t\t\t// iesProfile\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.iesTexture ? iesTextures.indexOf( l.iesTexture ) : - 1;\n\n\t\t\t} else if ( l.isPointLight ) {\n\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\tindex += 4;\n\n\t\t\t\t// sample 5\n\t\t\t\tindex += 1;\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\n\n\t\t\t} else if ( l.isDirectionalLight ) {\n\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\n\t\t\t\tconst targetPosition = v.setFromMatrixPosition( l.target.matrixWorld );\n\t\t\t\ttarget.subVectors( worldPosition, targetPosition ).normalize();\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\ttex.needsUpdate = true;\n\t\tthis.count = lights.length;\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFileLoader,\n\tHalfFloatType,\n\tLinearFilter,\n\tRedFormat,\n\tMathUtils,\n\tLoader,\n} from 'three';\n\nimport { toHalfFloatArray } from './TextureUtils.js';\n\nfunction IESLamp( text ) {\n\n\tconst _self = this;\n\n\tconst textArray = text.split( '\\n' );\n\n\tlet lineNumber = 0;\n\tlet line;\n\n\t_self.verAngles = [ ];\n\t_self.horAngles = [ ];\n\n\t_self.candelaValues = [ ];\n\n\t_self.tiltData = { };\n\t_self.tiltData.angles = [ ];\n\t_self.tiltData.mulFactors = [ ];\n\n\tfunction textToArray( text ) {\n\n\t\ttext = text.trim(); // remove leading or trailing spaces\n\t\ttext = text.replace( /,/g, ' ' ); // replace commas with spaces\n\t\ttext = text.replace( /\\s\\s+/g, ' ' ); // replace white space/tabs etc by single whitespace\n\n\t\tconst array = text.split( ' ' );\n\n\t\treturn array;\n\n\t}\n\n\tfunction readArray( count, array ) {\n\n\t\twhile ( true ) {\n\n\t\t\tconst line = textArray[ lineNumber ++ ];\n\t\t\tconst lineData = textToArray( line );\n\n\t\t\tfor ( let i = 0; i < lineData.length; ++ i ) {\n\n\t\t\t\tarray.push( Number( lineData[ i ] ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length === count )\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction readTilt() {\n\n\t\tlet line = textArray[ lineNumber ++ ];\n\t\tlet lineData = textToArray( line );\n\n\t\t_self.tiltData.lampToLumGeometry = Number( lineData[ 0 ] );\n\n\t\tline = textArray[ lineNumber ++ ];\n\t\tlineData = textToArray( line );\n\n\t\t_self.tiltData.numAngles = Number( lineData[ 0 ] );\n\n\t\treadArray( _self.tiltData.numAngles, _self.tiltData.angles );\n\t\treadArray( _self.tiltData.numAngles, _self.tiltData.mulFactors );\n\n\t}\n\n\tfunction readLampValues() {\n\n\t\tconst values = [ ];\n\t\treadArray( 10, values );\n\n\t\t_self.count = Number( values[ 0 ] );\n\t\t_self.lumens = Number( values[ 1 ] );\n\t\t_self.multiplier = Number( values[ 2 ] );\n\t\t_self.numVerAngles = Number( values[ 3 ] );\n\t\t_self.numHorAngles = Number( values[ 4 ] );\n\t\t_self.gonioType = Number( values[ 5 ] );\n\t\t_self.units = Number( values[ 6 ] );\n\t\t_self.width = Number( values[ 7 ] );\n\t\t_self.length = Number( values[ 8 ] );\n\t\t_self.height = Number( values[ 9 ] );\n\n\t}\n\n\tfunction readLampFactors() {\n\n\t\tconst values = [ ];\n\t\treadArray( 3, values );\n\n\t\t_self.ballFactor = Number( values[ 0 ] );\n\t\t_self.blpFactor = Number( values[ 1 ] );\n\t\t_self.inputWatts = Number( values[ 2 ] );\n\n\t}\n\n\twhile ( true ) {\n\n\t\tline = textArray[ lineNumber ++ ];\n\n\t\tif ( line.includes( 'TILT' ) ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tif ( ! line.includes( 'NONE' ) ) {\n\n\t\tif ( line.includes( 'INCLUDE' ) ) {\n\n\t\t\treadTilt();\n\n\t\t} else {\n\n\t\t\t// TODO:: Read tilt data from a file\n\n\t\t}\n\n\t}\n\n\treadLampValues();\n\n\treadLampFactors();\n\n\t// Initialize candela value array\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\t_self.candelaValues.push( [ ] );\n\n\t}\n\n\t// Parse Angles\n\treadArray( _self.numVerAngles, _self.verAngles );\n\treadArray( _self.numHorAngles, _self.horAngles );\n\n\t// Parse Candela values\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\treadArray( _self.numVerAngles, _self.candelaValues[ i ] );\n\n\t}\n\n\t// Calculate actual candela values, and normalize.\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\tfor ( let j = 0; j < _self.numVerAngles; ++ j ) {\n\n\t\t\t_self.candelaValues[ i ][ j ] *= _self.candelaValues[ i ][ j ] * _self.multiplier\n\t\t\t\t* _self.ballFactor * _self.blpFactor;\n\n\t\t}\n\n\t}\n\n\tlet maxVal = - 1;\n\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\tfor ( let j = 0; j < _self.numVerAngles; ++ j ) {\n\n\t\t\tconst value = _self.candelaValues[ i ][ j ];\n\t\t\tmaxVal = maxVal < value ? value : maxVal;\n\n\t\t}\n\n\t}\n\n\tconst bNormalize = true;\n\tif ( bNormalize && maxVal > 0 ) {\n\n\t\tfor ( let i = 0; i < _self.numHorAngles; ++ i ) {\n\n\t\t\tfor ( let j = 0; j < _self.numVerAngles; ++ j ) {\n\n\t\t\t\t_self.candelaValues[ i ][ j ] /= maxVal;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport class IESLoader extends Loader {\n\n\t_getIESValues( iesLamp ) {\n\n\t\tconst width = 360;\n\t\tconst height = 180;\n\t\tconst size = width * height;\n\n\t\tconst data = new Float32Array( size );\n\n\t\tfunction interpolateCandelaValues( phi, theta ) {\n\n\t\t\tlet phiIndex = 0, thetaIndex = 0;\n\t\t\tlet startTheta = 0, endTheta = 0, startPhi = 0, endPhi = 0;\n\n\t\t\tfor ( let i = 0; i < iesLamp.numHorAngles - 1; ++ i ) { // numHorAngles = horAngles.length-1 because of extra padding, so this wont cause an out of bounds error\n\n\t\t\t\tif ( theta < iesLamp.horAngles[ i + 1 ] || i == iesLamp.numHorAngles - 2 ) {\n\n\t\t\t\t\tthetaIndex = i;\n\t\t\t\t\tstartTheta = iesLamp.horAngles[ i ];\n\t\t\t\t\tendTheta = iesLamp.horAngles[ i + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < iesLamp.numVerAngles - 1; ++ i ) {\n\n\t\t\t\tif ( phi < iesLamp.verAngles[ i + 1 ] || i == iesLamp.numVerAngles - 2 ) {\n\n\t\t\t\t\tphiIndex = i;\n\t\t\t\t\tstartPhi = iesLamp.verAngles[ i ];\n\t\t\t\t\tendPhi = iesLamp.verAngles[ i + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deltaTheta = endTheta - startTheta;\n\t\t\tconst deltaPhi = endPhi - startPhi;\n\n\t\t\tif ( deltaPhi === 0 ) // Outside range\n\t\t\t\treturn 0;\n\n\t\t\tconst t1 = deltaTheta === 0 ? 0 : ( theta - startTheta ) / deltaTheta;\n\t\t\tconst t2 = ( phi - startPhi ) / deltaPhi;\n\n\t\t\tconst nextThetaIndex = deltaTheta === 0 ? thetaIndex : thetaIndex + 1;\n\n\t\t\tconst v1 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex ], t1 );\n\t\t\tconst v2 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex + 1 ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex + 1 ], t1 );\n\t\t\tconst v = MathUtils.lerp( v1, v2, t2 );\n\n\t\t\treturn v;\n\n\t\t}\n\n\t\tconst startTheta = iesLamp.horAngles[ 0 ], endTheta = iesLamp.horAngles[ iesLamp.numHorAngles - 1 ];\n\t\tfor ( let i = 0; i < size; ++ i ) {\n\n\t\t\tlet theta = i % width;\n\t\t\tconst phi = Math.floor( i / width );\n\n\t\t\tif ( endTheta - startTheta !== 0 && ( theta < startTheta || theta >= endTheta ) ) { // Handle symmetry for hor angles\n\n\t\t\t\ttheta %= endTheta * 2;\n\t\t\t\tif ( theta > endTheta )\n\t\t\t\t\ttheta = endTheta * 2 - theta;\n\n\t\t\t}\n\n\t\t\tdata[ i ] = interpolateCandelaValues( phi, theta );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'text' );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\n\t\tconst texture = new DataTexture( null, 360, 180, RedFormat, HalfFloatType );\n\t\ttexture.minFilter = LinearFilter;\n\t\ttexture.magFilter = LinearFilter;\n\n\t\tloader.load( url, text => {\n\n\t\t\tconst iesLamp = new IESLamp( text );\n\n\t\t\ttexture.image.data = toHalfFloatArray( this._getIESValues( iesLamp ) );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst iesLamp = new IESLamp( text );\n\t\tconst texture = new DataTexture( null, 360, 180, RedFormat, HalfFloatType );\n\t\ttexture.minFilter = LinearFilter;\n\t\ttexture.magFilter = LinearFilter;\n\t\ttexture.image.data = toHalfFloatArray( this._getIESValues( iesLamp ) );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n","import {\n\tClampToEdgeWrapping,\n\tColor,\n\tHalfFloatType,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tNoToneMapping,\n\tRGBAFormat,\n\tWebGLArrayRenderTarget,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { IESLoader } from '../utils/IESLoader.js';\n\nconst prevColor = new Color();\nexport class IESProfilesTexture extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = HalfFloatType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = ClampToEdgeWrapping;\n\t\ttex.wrapT = ClampToEdgeWrapping;\n\t\ttex.generateMipmaps = false;\n\n\t\ttex.updateFrom = ( ...args ) => {\n\n\t\t\tthis.updateFrom( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t\tthis.iesLoader = new IESLoader();\n\n\t}\n\n\tasync updateFrom( renderer, textures ) {\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\n\t\tconst depth = textures.length || 1;\n\t\tthis.setSize( 360, 180, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\t\t\tif ( texture ) {\n\n\t\t\t\t// revert to default texture transform before rendering\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t\ttexture.matrix.identity();\n\n\t\t\t\tfsQuad.material.map = texture;\n\t\t\t\tfsQuad.material.transparent = true;\n\n\t\t\t\trenderer.setRenderTarget( this, i );\n\t\t\t\tfsQuad.render( renderer );\n\n\t\t\t\t// restore custom texture transform\n\t\t\t\ttexture.updateMatrix();\n\t\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t\tfsQuad.dispose();\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n","export const utilsGLSL = /* glsl */`\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n","import { WebGLRenderTarget, RGBAFormat, HalfFloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { utilsGLSL } from '../shader/common/utils.glsl.js';\n\nclass PMREMCopyMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tblur: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ utilsGLSL }\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class BlurredEnvMapGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: HalfFloatType, format: RGBAFormat } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.pmremGenerator.dispose();\n\t\tthis.copyQuad.dispose();\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\tgenerate( texture, blur ) {\n\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\n\n\t\t// get the pmrem target\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\n\n\t\t// set up the material\n\t\tconst { width, height } = texture.image;\n\t\trenderTarget.setSize( width, height );\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\n\t\tcopyQuad.material.blur = blur;\n\n\t\t// render\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\t\tcopyQuad.render( renderer );\n\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.autoClear = prevClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Uint16Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, buffer );\n\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\n\t\tresult.minFilter = texture.minFilter;\n\t\tresult.magFilter = texture.magFilter;\n\t\tresult.wrapS = texture.wrapS;\n\t\tresult.wrapT = texture.wrapT;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\t// dispose of the now unneeded target\n\t\tpmremTarget.dispose();\n\n\t\treturn result;\n\n\t}\n\n}\n","import { NoBlending } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class DenoiseMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\ttransparent: false,\n\n\t\t\tdepthWrite: false,\n\n\t\t\tdepthTest: false,\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SLIDER: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsigma: { value: 5.0 },\n\t\t\t\tthreshold: { value: 0.03 },\n\t\t\t\tkSigma: { value: 1.0 },\n\n\t\t\t\tmap: { value: null },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\n\t\t\t\t//  All rights reserved.\n\t\t\t\t//\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\n\t\t\t\t//\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\n\t\t\t\t//\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\n\t\t\t\t//\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tuniform float sigma;\n\t\t\t\tuniform float threshold;\n\t\t\t\tuniform float kSigma;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\n\n\t\t\t\t// Parameters:\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\n\t\t\t\t//\t\t kSigma * sigma  -->  radius of the circular kernel\n\t\t\t\t//\t float threshold   - edge sharpening threshold\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\n\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\n\t\t\t\t\tfloat radQ = radius * radius;\n\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\n\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\n\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\n\n\t\t\t\t\tfloat zBuff = 0.0;\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\n\n\t\t\t\t\tvec2 d;\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\n\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\n\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\n\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\n\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\n\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\n\n\t\t\t\t\t\t\tzBuff += deltaFactor;\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aBuff / zBuff;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { Color, NoBlending } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class GradientMapMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tFEATURE_BIN: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\n\t\t\t\tminColor: { value: new Color( 0 ) },\n\t\t\t\tminValue: { value: 0 },\n\n\t\t\t\tmaxColor: { value: new Color( 0xffffff ) },\n\t\t\t\tmaxValue: { value: 10 },\n\n\t\t\t\tfield: { value: 0 },\n\t\t\t\tpower: { value: 1 },\n\n\t\t\t},\n\n\t\t\tblending: NoBlending,\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec3 minColor;\n\t\t\t\tuniform float minValue;\n\t\t\t\tuniform vec3 maxColor;\n\t\t\t\tuniform float maxValue;\n\t\t\t\tuniform int field;\n\t\t\t\tuniform float power;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat value = texture( map, vUv )[ field ];\n\n\t\t\t\t\t#if FEATURE_BIN\n\n\t\t\t\t\tvalue = ceil( value );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat t = smoothstep( minValue, maxValue, value );\n\t\t\t\t\tt = pow( t, power );\n\n\t\t\t\t\tgl_FragColor.rgb = vec3( mix( minColor, maxColor, t ) );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t\t}`,\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { NoBlending, Color, Vector2, Vector4 } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class GraphMaterial extends MaterialBase {\n\n\tget graphFunctionSnippet() {\n\n\t\treturn this._graphFunctionSnippet;\n\n\t}\n\n\tset graphFunctionSnippet( v ) {\n\n\t\tthis._graphFunctionSnippet = v;\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\ttransparent: false,\n\n\t\t\tdepthWrite: false,\n\n\t\t\tdepthTest: false,\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SLIDER: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tdim: { value: true },\n\t\t\t\tthickness: { value: 1 },\n\t\t\t\tgraphCount: { value: 4 },\n\t\t\t\tgraphDisplay: { value: new Vector4( 1.0, 1.0, 1.0, 1.0 ) },\n\t\t\t\toverlay: { value: true },\n\t\t\t\txRange: { value: new Vector2( - 2.0, 2.0 ) },\n\t\t\t\tyRange: { value: new Vector2( - 2.0, 2.0 ) },\n\t\t\t\tcolors: { value: [\n\t\t\t\t\tnew Color( 0xe91e63 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0x4caf50 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0x03a9f4 ).convertSRGBToLinear(),\n\t\t\t\t\tnew Color( 0xffc107 ).convertSRGBToLinear(),\n\t\t\t\t] },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform bool overlay;\n\t\t\t\tuniform bool dim;\n\t\t\t\tuniform bvec4 graphDisplay;\n\t\t\t\tuniform float graphCount;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 xRange;\n\t\t\t\tuniform vec2 yRange;\n\t\t\t\tuniform vec3 colors[ 4 ];\n\n\t\t\t\t__FUNCTION_CONTENT__\n\n\t\t\t\tfloat map( float _min, float _max, float v ) {\n\n\t\t\t\t\tfloat len = _max - _min;\n\t\t\t\t\treturn _min + len * v;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getBackground( vec2 point, float steepness ) {\n\n\t\t\t\t\tvec2 pw = fwidth( point );\n\t\t\t\t\tvec2 halfWidth = pw * 0.5;\n\n\t\t\t\t\t// x, y axes\n\t\t\t\t\tvec2 distToZero = smoothstep(\n\t\t\t\t\t\t- halfWidth * 0.5,\n\t\t\t\t\t\thalfWidth * 0.5,\n\t\t\t\t\t\tabs( point.xy ) - pw\n\t\t\t\t\t);\n\n\t\t\t\t\t// 1 unit markers\n\t\t\t\t\tvec2 temp;\n\t\t\t\t\tvec2 modAxis = abs( modf( point + vec2( 0.5 ), temp ) ) - 0.5;\n\t\t\t\t\tvec2 distToAxis = smoothstep(\n\t\t\t\t\t\t- halfWidth,\n\t\t\t\t\t\thalfWidth,\n\t\t\t\t\t\tabs( modAxis.xy ) - pw * 0.5\n\t\t\t\t\t);\n\n\t\t\t\t\t// if we're at a chart boundary then remove the artifacts\n\t\t\t\t\tif ( abs( pw.y ) > steepness * 0.5 ) {\n\n\t\t\t\t\t\tdistToZero.y = 1.0;\n\t\t\t\t\t\tdistToAxis.y = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mix colors into a background color\n\t\t\t\t\tfloat axisIntensity = 1.0 - min( distToZero.x, distToZero.y );\n\t\t\t\t\tfloat markerIntensity = 1.0 - min( distToAxis.x, distToAxis.y );\n\n\t\t\t\t\tvec3 markerColor = mix( vec3( 0.005 ), vec3( 0.05 ), markerIntensity );\n\t\t\t\t\tvec3 backgroundColor = mix( markerColor, vec3( 0.2 ), axisIntensity );\n\t\t\t\t\treturn backgroundColor;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// from uniforms\n\t\t\t\t\tfloat sectionCount = overlay ? 1.0 : graphCount;\n\t\t\t\t\tfloat yWidth = abs( yRange.y - yRange.x );\n\n\t\t\t\t\t// separate into sections\n\t\t\t\t\tfloat _section;\n\t\t\t\t\tfloat sectionY = modf( sectionCount * vUv.y, _section );\n\t\t\t\t\tint section = int( sectionCount - _section - 1.0 );\n\n\t\t\t\t\t// get the current point\n\t\t\t\t\tvec2 point = vec2(\n\t\t\t\t\t\tmap( xRange.x, xRange.y, vUv.x ),\n\t\t\t\t\t\tmap( yRange.x, yRange.y, sectionY )\n\t\t\t\t\t);\n\n\t\t\t\t\t// get the results\n\t\t\t\t\tvec4 result = graphFunction( point.x );\n\t\t\t\t\tvec4 delta = result - vec4( point.y );\n\t\t\t\t\tvec4 halfDdf = fwidth( delta ) * 0.5;\n\t\t\t\t\tif ( fwidth( point.y ) > yWidth * 0.5 ) {\n\n\t\t\t\t\t\thalfDdf = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph display intensity\n\t\t\t\t\tvec4 graph = smoothstep( - halfDdf, halfDdf, abs( delta ) - thickness * halfDdf );\n\n\t\t\t\t\t// initialize the background\n\t\t\t\t\tgl_FragColor.rgb = getBackground( point, yWidth );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\tif ( dim && ( point.x < 0.0 || point.y < 0.0 ) ) {\n\n\t\t\t\t\t\tgraph = mix(\n\t\t\t\t\t\t\tvec4( 1.0 ),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t0.05\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// color the charts\n\t\t\t\t\tif ( sectionCount > 1.0 ) {\n\n\t\t\t\t\t\tif ( graphDisplay[ section ] ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\tcolors[ section ],\n\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\tgraph[ section ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( int i = 0; i < int( graphCount ); i ++ ) {\n\n\t\t\t\t\t\t\tif ( graphDisplay[ i ] ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\t\tcolors[ i ],\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\t\tgraph[ i ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\n\t\tthis._graphFunctionSnippet = /* glsl */`\n\t\t\tvec4 graphFunctionSnippet( float x ) {\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tsin( x * 3.1415926535 ),\n\t\t\t\t\tcos( x ),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t);\n\n\t\t\t}\n\t\t`;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tonBeforeCompile( shader ) {\n\n\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t'__FUNCTION_CONTENT__',\n\t\t\tthis._graphFunctionSnippet,\n\t\t);\n\t\treturn shader;\n\n\t}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this._graphFunctionSnippet;\n\n\t}\n\n}\n","import { DataArrayTexture, FloatType, RGBAFormat } from 'three';\nimport { FloatVertexAttributeTexture } from 'three-mesh-bvh';\n\nfunction copyArrayToArray( fromArray, fromStride, toArray, toStride, offset ) {\n\n\tif ( fromStride > toStride ) {\n\n\t\tthrow new Error();\n\n\t}\n\n\t// scale non-float values to their normalized range\n\tconst count = fromArray.length / fromStride;\n\tconst bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\n\tlet maxValue = 1.0;\n\tswitch ( fromArray.constructor ) {\n\n\tcase Uint8Array:\n\tcase Uint16Array:\n\tcase Uint32Array:\n\t\tmaxValue = 2 ** bpe - 1;\n\t\tbreak;\n\n\tcase Int8Array:\n\tcase Int16Array:\n\tcase Int32Array:\n\t\tmaxValue = 2 ** ( bpe - 1 ) - 1;\n\t\tbreak;\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tconst i4 = 4 * i;\n\t\tconst is = fromStride * i;\n\t\tfor ( let j = 0; j < toStride; j ++ ) {\n\n\t\t\ttoArray[ offset + i4 + j ] = fromStride >= j + 1 ? fromArray[ is + j ] / maxValue : 0;\n\n\t\t}\n\n\t}\n\n}\n\nexport class FloatAttributeTextureArray extends DataArrayTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._textures = [];\n\t\tthis.type = FloatType;\n\t\tthis.format = RGBAFormat;\n\t\tthis.internalFormat = 'RGBA32F';\n\n\t}\n\n\tupdateAttribute( index, attr ) {\n\n\t\t// update the texture\n\t\tconst tex = this._textures[ index ];\n\t\ttex.updateFrom( attr );\n\n\t\t// ensure compatibility\n\t\tconst baseImage = tex.image;\n\t\tconst image = this.image;\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height ) {\n\n\t\t\tthrow new Error( 'FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.' );\n\n\t\t}\n\n\t\t// update the image\n\t\tconst { width, height, data } = image;\n\t\tconst length = width * height * 4;\n\t\tconst offset = length * index;\n\t\tlet itemSize = attr.itemSize;\n\t\tif ( itemSize === 3 ) {\n\n\t\t\titemSize = 4;\n\n\t\t}\n\n\t\t// copy the data\n\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tsetAttributes( attrs ) {\n\n\t\t// ensure the attribute count\n\t\tconst itemCount = attrs[ 0 ].count;\n\t\tconst attrsLength = attrs.length;\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\tif ( attrs[ i ].count !== itemCount ) {\n\n\t\t\t\tthrow new Error( 'FloatAttributeTextureArray: All attributes must have the same item count.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize all textures\n\t\tconst textures = this._textures;\n\t\twhile ( textures.length < attrsLength ) {\n\n\t\t\tconst tex = new FloatVertexAttributeTexture();\n\t\t\ttextures.push( tex );\n\n\t\t}\n\n\t\twhile ( textures.length > attrsLength ) {\n\n\t\t\ttextures.pop();\n\n\t\t}\n\n\t\t// update all textures\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\ttextures[ i ].updateFrom( attrs[ i ] );\n\n\t\t}\n\n\t\t// determine if we need to create a new array\n\t\tconst baseTexture = textures[ 0 ];\n\t\tconst baseImage = baseTexture.image;\n\t\tconst image = this.image;\n\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength ) {\n\n\t\t\timage.width = baseImage.width;\n\t\t\timage.height = baseImage.height;\n\t\t\timage.depth = attrsLength;\n\t\t\timage.data = new Float32Array( image.width * image.height * image.depth * 4 );\n\n\t\t}\n\n\t\t// copy the other texture data into the data array texture\n\t\tconst { data, width, height } = image;\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\tconst tex = textures[ i ];\n\t\t\tconst length = width * height * 4;\n\t\t\tconst offset = length * i;\n\n\t\t\tlet itemSize = attrs[ i ].itemSize;\n\t\t\tif ( itemSize === 3 ) {\n\n\t\t\t\titemSize = 4;\n\n\t\t\t}\n\n\t\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\n\n\t\t}\n\n\t\t// reset the texture\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\n}\n","import { FloatAttributeTextureArray } from './FloatAttributeTextureArray.js';\n\nexport class AttributesTextureArray extends FloatAttributeTextureArray {\n\n\tupdateNormalAttribute( attr ) {\n\n\t\tthis.updateAttribute( 0, attr );\n\n\t}\n\n\tupdateTangentAttribute( attr ) {\n\n\t\tthis.updateAttribute( 1, attr );\n\n\t}\n\n\tupdateUvAttribute( attr ) {\n\n\t\tthis.updateAttribute( 2, attr );\n\n\t}\n\n\tupdateColorAttribute( attr ) {\n\n\t\tthis.updateAttribute( 3, attr );\n\n\t}\n\n\tupdateFrom( normal, tangent, uv, color ) {\n\n\t\tthis.setAttributes( [ normal, tangent, uv, color ] );\n\n\t}\n\n}\n","export const cameraStructGLSL = /* glsl */`\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n`;\n","export const equirectStructGLSL = /* glsl */`\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\n\t\tfloat totalSum;\n\n\t};\n\n`;\n","export const lightsStructGLSL = /* glsl */`\n\n\t#define RECT_AREA_LIGHT_TYPE 0\n\t#define CIRC_AREA_LIGHT_TYPE 1\n\t#define SPOT_LIGHT_TYPE 2\n\t#define DIR_LIGHT_TYPE 3\n\t#define POINT_LIGHT_TYPE 4\n\n\tstruct LightsInfo {\n\n\t\tsampler2D tex;\n\t\tuint count;\n\n\t};\n\n\tstruct Light {\n\n\t\tvec3 position;\n\t\tint type;\n\n\t\tvec3 color;\n\t\tfloat intensity;\n\n\t\tvec3 u;\n\t\tvec3 v;\n\t\tfloat area;\n\n\t\t// spot light fields\n\t\tfloat radius;\n\t\tfloat near;\n\t\tfloat decay;\n\t\tfloat distance;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint iesProfile;\n\n\t};\n\n\tLight readLightInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 6u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\n\t\tLight l;\n\t\tl.position = s0.rgb;\n\t\tl.type = int( round( s0.a ) );\n\n\t\tl.color = s1.rgb;\n\t\tl.intensity = s1.a;\n\n\t\tl.u = s2.rgb;\n\t\tl.v = s3.rgb;\n\t\tl.area = s3.a;\n\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\t\tl.radius = s4.r;\n\t\t\tl.decay = s4.g;\n\t\t\tl.distance = s4.b;\n\t\t\tl.coneCos = s4.a;\n\n\t\t\tl.penumbraCos = s5.r;\n\t\t\tl.iesProfile = int( round( s5.g ) );\n\n\t\t} else {\n\n\t\t\tl.radius = 0.0;\n\t\t\tl.decay = 0.0;\n\t\t\tl.distance = 0.0;\n\n\t\t\tl.coneCos = 0.0;\n\t\t\tl.penumbraCos = 0.0;\n\t\t\tl.iesProfile = - 1;\n\n\t\t}\n\n\t\treturn l;\n\n\t}\n\n`;\n","export const materialStructGLSL = /* glsl */ `\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 45u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = ! bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\t// mat3( 1.0 ) is an identity matrix\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\n\t\treturn m;\n\n\t}\n\n`;\n","export const fogMaterialBvhGLSL = /* glsl */`\n\n#ifndef FOG_CHECK_ITERATIONS\n#define FOG_CHECK_ITERATIONS 30\n#endif\n\n// returns whether the given material is a fog material or not\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\n\n\tuint i = materialIndex * 45u;\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\n\treturn bool( int( s14.b ) & 4 );\n\n}\n\n// returns true if we're within the first fog volume we hit\nbool bvhIntersectFogVolumeHit(\n\tvec3 rayOrigin, vec3 rayDirection,\n\tusampler2D materialIndexAttribute, sampler2D materials,\n\tinout Material material\n) {\n\n\tmaterial.fogVolume = false;\n\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\n\n\t\t// find nearest hit\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tif ( hit ) {\n\n\t\t\t// if it's a fog volume return whether we hit the front or back face\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\n\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\n\t\t\t\treturn side == - 1.0;\n\n\t\t\t} else {\n\n\t\t\t\t// move the ray forward\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n`;\n","export const ggxGLSL = /* glsl */`\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n","export const sheenGLSL = /* glsl */`\n\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetD( float cosThetaH, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat invAlpha = 1.0 / alpha;\n\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n\t}\n\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n\t}\n\n\tfloat velvetL( float x, float alpha ) {\n\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n\t}\n\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetLambda( float cosTheta, float alpha ) {\n\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n\t}\n\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n\t}\n\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\t\tcosTheta = saturate( cosTheta );\n\n\t\tfloat c = 1.0 - cosTheta;\n\t\tfloat c3 = c * c * c;\n\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n\t}\n\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n\t}\n\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\t\treturn 1.0 - maxSheenColor * eWo;\n\n\t}\n\n`;\n","export const iridescenceGLSL = /* glsl */`\n\n\t// XYZ to sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\t\treturn srgb;\n\n\t}\n\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\treturn vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIor < outsideIOR ) {\n\n\t\t\tphi12 = PI;\n\n\t\t}\n\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\t\tphi23[ 0 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\t\tphi23[ 1 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\t\tphi23[ 2 ] = PI;\n\n\t\t}\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n`;\n","import { ggxGLSL } from './ggx.glsl.js';\nimport { sheenGLSL } from './sheen.glsl.js';\nimport { iridescenceGLSL } from './iridescence.glsl.js';\n\n/*\nwi     : incident vector or light vector (pointing toward the light)\nwo     : outgoing vector or view vector (pointing towards the camera)\nwh     : computed half vector from wo and wi\nEval   : Get the color and pdf for a direction\nSample : Get the direction, color, and pdf for a sample\neta    : Greek character used to denote the \"ratio of ior\"\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\nf90    : Amount of light reflected at grazing angles\n*/\n\nexport const bsdfSamplingGLSL = /* glsl */`\n\n\tstruct SurfaceRecord {\n\n\t\t// surface type\n\t\tbool volumeParticle;\n\n\t\t// geometry\n\t\tvec3 faceNormal;\n\t\tbool frontFace;\n\t\tvec3 normal;\n\t\tmat3 normalBasis;\n\t\tmat3 normalInvBasis;\n\n\t\t// cached properties\n\t\tfloat eta;\n\t\tfloat f0;\n\n\t\t// material\n\t\tfloat roughness;\n\t\tfloat filteredRoughness;\n\t\tfloat metalness;\n\t\tvec3 color;\n\t\tvec3 emission;\n\n\t\t// transmission\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tbool thinFilm;\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\t// clearcoat\n\t\tvec3 clearcoatNormal;\n\t\tmat3 clearcoatBasis;\n\t\tmat3 clearcoatInvBasis;\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tfloat filteredClearcoatRoughness;\n\n\t\t// sheen\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\n\t\t// iridescence\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThickness;\n\n\t\t// specular\n\t\tvec3 specularColor;\n\t\tfloat specularIntensity;\n\t};\n\n\tstruct ScatterRecord {\n\t\tfloat specularPdf;\n\t\tfloat pdf;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\t${ ggxGLSL }\n\t${ sheenGLSL }\n\t${ iridescenceGLSL }\n\n\t// diffuse\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t\t// TODO: subsurface approx?\n\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\n\t\treturn wi.z / PI;\n\n\t}\n\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\n\t\tlightDirection.z += 1.0;\n\t\tlightDirection = normalize( lightDirection );\n\n\t\treturn lightDirection;\n\n\t}\n\n\t// specular\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\n\t\tfloat metalness = surf.metalness;\n\t\tfloat roughness = surf.filteredRoughness;\n\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\n\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\n\n\t\t// PDF\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\t\tfloat incidentTheta = acos( wo.z );\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n\t}\n\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\trand2( 12 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\n\t// transmission\n\t/*\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\t\tbool thinFilm = surf.thinFilm;\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( filteredRoughness ),\n\t\t\trand2( 13 )\n\t\t);\n\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\n\t\treturn normalize( lightDirection );\n\n\t}\n\t*/\n\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\t// PDF\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\t\tif ( F >= 1.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 1.0 - F );\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\t\treturn normalize( lightDirection );\n\n\t}\n\n\t// clearcoat\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tfloat ior = 1.5;\n\t\tfloat f0 = iorRatioToF0( ior );\n\t\tbool frontFace = surf.frontFace;\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t\t// PDF\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\n\n\t}\n\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\trand2( 14 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\t// sheen\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\n\n\t\tfloat cosThetaO = saturateCos( wo.z );\n\t\tfloat cosThetaI = saturateCos( wi.z );\n\t\tfloat cosThetaH = wh.z;\n\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\t\tvec3 color = surf.sheenColor;\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\t\tcolor *= wi.z;\n\n\t\treturn color;\n\n\t}\n\n\t// bsdf\n\tvoid getLobeWeights(\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\t\tdiffuseWeight /= totalWeight;\n\t\tspecularWeight /= totalWeight;\n\t\ttransmissionWeight /= totalWeight;\n\t\tclearcoatWeight /= totalWeight;\n\t}\n\n\tfloat bsdfEval(\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\n\t\tfloat spdf = 0.0;\n\t\tfloat dpdf = 0.0;\n\t\tfloat tpdf = 0.0;\n\t\tfloat cpdf = 0.0;\n\t\tcolor = vec3( 0.0 );\n\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t\t// diffuse\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\t// ggx specular\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tvec3 outColor;\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\t\tcolor += outColor;\n\n\t\t}\n\n\t\t// transmission\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t\t}\n\n\t\t// sheen\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\n\n\t\t// clearcoat\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t\t}\n\n\t\tfloat pdf =\n\t\t\tdpdf * diffuseWeight\n\t\t\t+ spdf * specularWeight\n\t\t\t+ tpdf * transmissionWeight\n\t\t\t+ cpdf * clearcoatWeight;\n\n\t\t// retrieve specular rays for the shadows flag\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\t\treturn pdf;\n\n\t}\n\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tcolor = surf.color / ( 4.0 * PI );\n\t\t\treturn 1.0 / ( 4.0 * PI );\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\n\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\n\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat specularPdf;\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n\t}\n\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tScatterRecord sampleRec;\n\t\t\tsampleRec.specularPdf = 0.0;\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\n\t\t\treturn sampleRec;\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tmat3 normalBasis = surf.normalBasis;\n\t\tmat3 invBasis = surf.normalInvBasis;\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\n\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat pdf[4];\n\t\tpdf[0] = diffuseWeight;\n\t\tpdf[1] = specularWeight;\n\t\tpdf[2] = transmissionWeight;\n\t\tpdf[3] = clearcoatWeight;\n\n\t\tfloat cdf[4];\n\t\tcdf[0] = pdf[0];\n\t\tcdf[1] = pdf[1] + cdf[0];\n\t\tcdf[2] = pdf[2] + cdf[1];\n\t\tcdf[3] = pdf[3] + cdf[2];\n\n\t\tif( cdf[3] != 0.0 ) {\n\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\t\tcdf[0] *= invMaxCdf;\n\t\t\tcdf[1] *= invMaxCdf;\n\t\t\tcdf[2] *= invMaxCdf;\n\t\t\tcdf[3] *= invMaxCdf;\n\n\t\t} else {\n\n\t\t\tcdf[0] = 1.0;\n\t\t\tcdf[1] = 0.0;\n\t\t\tcdf[2] = 0.0;\n\t\t\tcdf[3] = 0.0;\n\n\t\t}\n\n\t\tvec3 wi;\n\t\tvec3 clearcoatWi;\n\n\t\tfloat r = rand( 15 );\n\t\tif ( r <= cdf[0] ) { // diffuse\n\n\t\t\twi = diffuseDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[1] ) { // specular\n\n\t\t\twi = specularDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\t\twi = transmissionDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t\t}\n\n\t\tScatterRecord result;\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\t\tresult.direction = normalize( surf.normalBasis * wi );\n\n\t\treturn result;\n\n\t}\n\n`;\n","export const fogGLSL = /* glsl */`\n\n\t// returns the hit distance given the material density\n\tfloat intersectFogVolume( Material material, float u ) {\n\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\n\n\t}\n\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\n\n\t\tScatterRecord sampleRec;\n\t\tsampleRec.specularPdf = 0.0;\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\n\t\tsampleRec.direction = sampleSphere( uv );\n\t\tsampleRec.color = surf.color;\n\t\treturn sampleRec;\n\n\t}\n\n`;\n","export const equirectSamplingGLSL = /* glsl */`\n\n\t// samples the the given environment map in the given direction\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\n\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\n\n\t}\n\n\t// gets the pdf of the given direction to sample\n\tfloat equirectDirectionPdf( vec3 direction ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tfloat theta = uv.y * PI;\n\t\tfloat sinTheta = sin( theta );\n\t\tif ( sinTheta == 0.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n\t}\n\n\t// samples the color given env map with CDF and returns the pdf of the direction\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\n\n\t\tfloat totalSum = envMapInfo.totalSum;\n\t\tif ( totalSum == 0.0 ) {\n\n\t\t\tcolor = vec3( 0.0 );\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\n\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t// samples a direction of the envmap with color and retrieves pdf\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\n\n\t\t// sample env map cdf\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\n\t\tvec2 uv = vec2( u, v );\n\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\n\t\tdirection = derivedDirection;\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\n\n\t\tfloat totalSum = envMapInfo.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n`;\n","export const lightSamplingGLSL = /* glsl */`\n\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n\t}\n\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t}\n\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n\t\tfloat cosTheta = dot( posToLight, lightDir );\n\t\tfloat angle = acos( cosTheta ) * ( 1.0 / PI );\n\n\t\treturn texture2D( iesProfiles, vec3( 0.0, angle, iesProfile ) ).r;\n\n\t}\n\n\tstruct LightRecord {\n\n\t\tfloat dist;\n\t\tvec3 direction;\n\t\tfloat pdf;\n\t\tvec3 emission;\n\t\tint type;\n\n\t};\n\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\n\n\t\tbool didHit = false;\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\n\t\t// check for backface\n\t\tvec3 normal = normalize( cross( u, v ) );\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\n\n\t\t\tu *= 1.0 / dot( u, u );\n\t\t\tv *= 1.0 / dot( v, v );\n\n\t\t\tfloat dist;\n\n\t\t\t// MIS / light intersection is not supported for punctual lights.\n\t\t\tif(\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t\t) {\n\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\tdidHit = true;\n\t\t\t\tlightRec.dist = dist;\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\tlightRec.emission = light.color * light.intensity;\n\t\t\t\tlightRec.direction = rayDirection;\n\t\t\t\tlightRec.type = light.type;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn didHit;\n\n\t}\n\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tvec3 randomPos;\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t\t// rectangular area light\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t\t// circular area light\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\t\tfloat x = r * cos( theta );\n\t\t\tfloat y = r * sin( theta );\n\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t\t}\n\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\t\tvec3 direction = toLight / dist;\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.emission = light.color * light.intensity;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\n\t\t// TODO: the denominator is potentially zero\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tfloat radius = light.radius * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = radius * cos( theta );\n\t\tfloat y = radius * sin( theta );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\t\tvec3 normal = normalize( cross( u, v ) );\n\n\t\tfloat angle = acos( light.coneCos );\n\t\tfloat angleTan = tan( angle );\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / max( dist, EPSILON );\n\t\tfloat cosTheta = dot( direction, normal );\n\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\t\tlightRec.pdf = 1.0;\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t\tLightRecord result;\n\n\t\t// pick a random light\n\t\tuint l = uint( ruv.x * float( lightCount ) );\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec3 lightRay = light.u - rayOrigin;\n\t\t\tfloat lightDist = length( lightRay );\n\t\t\tfloat cutoffDistance = light.distance;\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t\t}\n\n\t\t\tLightRecord rec;\n\t\t\trec.direction = normalize( lightRay );\n\t\t\trec.dist = length( lightRay );\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\t\trec.type = light.type;\n\t\t\tresult = rec;\n\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\t\tLightRecord rec;\n\t\t\trec.dist = 1e10;\n\t\t\trec.direction = light.u;\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity;\n\t\t\trec.type = light.type;\n\n\t\t\tresult = rec;\n\n\t\t} else {\n\n\t\t\t// sample the light\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n`;\n","export const shapeSamplingGLSL = /* glsl */`\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n`;\n","export const intersectShapesGLSL = /* glsl */`\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the rectangle on that same plane.\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\n\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = p - center;\n\n\t\t\t// check if p falls inside the rectangle\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\n\n\t\t\t\tfloat a2 = dot( v, vi );\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\n\n\t\t\t\t\tdist = t;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\n\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = hit - position;\n\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tfloat a2 = dot( v, vi );\n\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\n\n\t\t\t\tdist = t;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n`;\n","export const mathGLSL = /* glsl */`\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n","export const fresnelGLSL = /* glsl */`\n\n\tbool totalInternalReflection( float cosTheta, float eta ) {\n\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\treturn eta * sinTheta > 1.0;\n\n\t}\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\n\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat ni = eta;\n\t\tfloat nt = 1.0;\n\n\t\t// Check for total internal reflection\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\n\t\tif( sinThetaTSq >= 1.0 ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\n\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat iorRatioToF0( float eta ) {\n\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\n\n\t}\n\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn f90;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\n\n\t}\n\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\n\t// the glTF but is causing blown out pixels. Should be revisited\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\n\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t// \t\treturn 1.0;\n\n\t// \t}\n\n\t// \treturn schlickFresnel( cosTheta, f0 );\n\n\t// }\n\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\n\n\t\tfloat dotHV = dot( wo, wh );\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat dotHL = dot( wi, wh );\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\n\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\n\n\t}\n\n`;\n","\nexport const arraySamplerTexelFetchGLSL = /*glsl */`\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n`;\n","export const pcgGLSL = /* glsl */`\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat pcgRand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 pcgRand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 pcgRand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 pcgRand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n`;\n","export const renderStructsGLSL = /* glsl */`\n\n\tstruct Ray {\n\n\t\tvec3 origin;\n\t\tvec3 direction;\n\n\t};\n\n\tstruct SurfaceHit {\n\n\t\tuvec4 faceIndices;\n\t\tvec3 barycoord;\n\t\tvec3 faceNormal;\n\t\tfloat side;\n\t\tfloat dist;\n\n\t};\n\n\tstruct RenderState {\n\n\t\tbool firstRay;\n\t\tbool transmissiveRay;\n\t\tbool isShadowRay;\n\t\tfloat accumulatedRoughness;\n\t\tint transmissiveTraversals;\n\t\tint traversals;\n\t\tuint depth;\n\t\tvec3 throughputColor;\n\t\tMaterial fogMaterial;\n\n\t};\n\n\tRenderState initRenderState() {\n\n\t\tRenderState result;\n\t\tresult.firstRay = true;\n\t\tresult.transmissiveRay = true;\n\t\tresult.isShadowRay = false;\n\t\tresult.accumulatedRoughness = 0.0;\n\t\tresult.transmissiveTraversals = 0;\n\t\tresult.traversals = 0;\n\t\tresult.throughputColor = vec3( 1.0 );\n\t\tresult.depth = 0u;\n\t\tresult.fogMaterial.fogVolume = false;\n\t\treturn result;\n\n\t}\n\n`;\n","export const cameraUtilsGLSL = /* glsl */`\n\n\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t}\n\n\tRay getCameraRay() {\n\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t// around this pixel's UV coordinate for AA\n\t\tvec2 ruv = rand2( 0 );\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\t\tRay ray;\n\n\t\t#if CAMERA_TYPE == 2\n\n\t\t\t// Equirectangular projection\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\tray.direction = normalize( rayDirection4.xyz );\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t#else\n\n\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\tray.origin = ndcToRayOrigin( ndc );\n\n\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t// Orthographic projection\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\tray.direction = normalize( ray.direction );\n\n\t\t\t#else\n\n\t\t\t\t// Perspective projection\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#if FEATURE_DOF\n\t\t{\n\n\t\t\t// depth of field\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\n\n\t\t\t// get the aperture sample\n\t\t\t// if blades === 0 then we assume a circle\n\t\t\tvec3 shapeUVW= rand3( 1 );\n\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t// rotate the aperture shape\n\t\t\tapertureSample =\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t// create the new ray\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\tray.direction = focalPoint - ray.origin;\n\n\t\t}\n\t\t#endif\n\n\t\tray.direction = normalize( ray.direction );\n\n\t\treturn ray;\n\n\t}\n\n`;\n","export const attenuateHitGLSL = /* glsl */`\n\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t// returns true if a solid surface was hit\n\tbool attenuateHit(\n\t\tRenderState state,\n\t\tRay ray, float rayDist,\n\t\tout vec3 color\n\t) {\n\n\t\t// store the original bounce index so we can reset it after\n\t\tuint originalBounceIndex = sobolBounceIndex;\n\n\t\tint traversals = state.traversals;\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\n\t\tbool isShadowRay = state.isShadowRay;\n\t\tMaterial fogMaterial = state.fogMaterial;\n\n\t\tvec3 startPoint = ray.origin;\n\n\t\t// hit results\n\t\tSurfaceHit surfaceHit;\n\n\t\tcolor = vec3( 1.0 );\n\n\t\tbool result = true;\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\tsobolBounceIndex ++;\n\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\n\n\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\n\t\t\t\tif ( totalDist > rayDist ) {\n\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t// adjust the ray to the new surface\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\tif ( material.fogVolume ) {\n\n\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t\t\t// albedo\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMap\n\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t}\n\n\t\t\t\t// transmission\n\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t}\n\n\t\t\t\t// metalness\n\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t}\n\n\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\tif (\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\n\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\n\n\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\n\n\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\n\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t}\n\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the bounce index\n\t\tsobolBounceIndex = originalBounceIndex;\n\t\treturn result;\n\n\t}\n\n`;\n","export const traceSceneGLSL = /* glsl */`\n\n\t#define NO_HIT 0\n\t#define SURFACE_HIT 1\n\t#define LIGHT_HIT 2\n\t#define FOG_HIT 3\n\n\t// Passing the global variable 'lights' into this function caused shader program errors.\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\n\t// For more information, refer to: https://github.com/gkjohnson/three-gpu-pathtracer/pull/457\n\tint traceScene(\n\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\n\n\t) {\n\n\t\tint result = NO_HIT;\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\n\n\t\t#if FEATURE_FOG\n\n\t\tif ( fogMaterial.fogVolume ) {\n\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\n\t\t\t// as other objects\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\n\n\t\t\t\tsurfaceHit.side = 1.0;\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\n\t\t\t\tsurfaceHit.dist = particleDist;\n\t\t\t\treturn FOG_HIT;\n\n\t\t\t}\n\n\t\t}\n\n\t\t#endif\n\n\t\tif ( hit ) {\n\n\t\t\tresult = SURFACE_HIT;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n`;\n","\nexport const getSurfaceRecordGLSL = /* glsl */`\n\n\t#define SKIP_SURFACE 0\n\t#define HIT_SURFACE 1\n\tint getSurfaceRecord(\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\n\t\tfloat accumulatedRoughness,\n\t\tinout SurfaceRecord surf\n\t) {\n\n\t\tif ( material.fogVolume ) {\n\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\n\n\t\t\tSurfaceRecord fogSurface;\n\t\t\tfogSurface.volumeParticle = true;\n\t\t\tfogSurface.color = material.color;\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\n\t\t\tfogSurface.normal = normal;\n\t\t\tfogSurface.faceNormal = normal;\n\t\t\tfogSurface.clearcoatNormal = normal;\n\n\t\t\tsurf = fogSurface;\n\t\t\treturn HIT_SURFACE;\n\n\t\t}\n\n\t\t// uv coord for textures\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t// albedo\n\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\tif ( material.map != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t}\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\talbedo *= vertexColor;\n\n\t\t}\n\n\t\t// alphaMap\n\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t}\n\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t// and it's single sided.\n\t\t// - alpha test is disabled when it === 0\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\tfloat alphaTest = material.alphaTest;\n\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\tif (\n\t\t\t// material sidedness\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\n\n\t\t\t// alpha test\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t// opacity\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\n\t\t) {\n\n\t\t\treturn SKIP_SURFACE;\n\n\t\t}\n\n\t\t// fetch the interpolated smooth normal\n\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\tattributesArray,\n\t\t\tATTR_NORMAL,\n\t\t\tsurfaceHit.barycoord,\n\t\t\tsurfaceHit.faceIndices.xyz\n\t\t).xyz );\n\n\t\t// roughness\n\t\tfloat roughness = material.roughness;\n\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t}\n\n\t\t// metalness\n\t\tfloat metalness = material.metalness;\n\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t}\n\n\t\t// emission\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t}\n\n\t\t// transmission\n\t\tfloat transmission = material.transmission;\n\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t}\n\n\t\t// normal\n\t\tif ( material.flatShading ) {\n\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t// interpolated vertex normals.\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\n\n\t\t}\n\n\t\tvec3 baseNormal = normal;\n\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnormal *= surfaceHit.side;\n\n\t\t// clearcoat\n\t\tfloat clearcoat = material.clearcoat;\n\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t}\n\n\t\t// clearcoatRoughness\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t}\n\n\t\t// clearcoatNormal\n\t\tvec3 clearcoatNormal = baseNormal;\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tclearcoatNormal *= surfaceHit.side;\n\n\t\t// sheenColor\n\t\tvec3 sheenColor = material.sheenColor;\n\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// sheenRoughness\n\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t}\n\n\t\t// iridescence\n\t\tfloat iridescence = material.iridescence;\n\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t}\n\n\t\t// iridescence thickness\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t}\n\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t// specular color\n\t\tvec3 specularColor = material.specularColor;\n\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// specular intensity\n\t\tfloat specularIntensity = material.specularIntensity;\n\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t}\n\n\t\tsurf.volumeParticle = false;\n\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\n\t\tsurf.normal = normal;\n\n\t\tsurf.metalness = metalness;\n\t\tsurf.color = albedo.rgb;\n\t\tsurf.emission = emission;\n\n\t\tsurf.ior = material.ior;\n\t\tsurf.transmission = transmission;\n\t\tsurf.thinFilm = material.thinFilm;\n\t\tsurf.attenuationColor = material.attenuationColor;\n\t\tsurf.attenuationDistance = material.attenuationDistance;\n\n\t\tsurf.clearcoatNormal = clearcoatNormal;\n\t\tsurf.clearcoat = clearcoat;\n\n\t\tsurf.sheen = material.sheen;\n\t\tsurf.sheenColor = sheenColor;\n\n\t\tsurf.iridescence = iridescence;\n\t\tsurf.iridescenceIor = material.iridescenceIor;\n\t\tsurf.iridescenceThickness = iridescenceThickness;\n\n\t\tsurf.specularColor = specularColor;\n\t\tsurf.specularIntensity = specularIntensity;\n\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\n\t\t// applied by its brdf function\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\tsurf.roughness = roughness * roughness;\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\tsurf.sheenRoughness = sheenRoughness;\n\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t// then we can just always assume this is a front face.\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\n\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t// sharp internal reflections\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\n\n\t\t// get the normal frames\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\n\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\n\n\t\treturn HIT_SURFACE;\n\n\t}\n`;\n","export const directLightContributionGLSL = /*glsl*/`\n\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\n\n\t\tvec3 result = vec3( 0.0 );\n\n\t\t// uniformly pick a light or environment map\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\n\n\t\t\t// sample a light or environment\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\n\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tlightRec.pdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the light area\n\t\t\tRay lightRay;\n\t\t\tlightRay.origin = rayOrigin;\n\t\t\tlightRay.direction = lightRec.direction;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tlightRec.pdf > 0.0 &&\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\n\n\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\tvec3 envColor, envDirection;\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t// results so we ignore the sample in this case.\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tenvPdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the surface\n\t\t\tRay envRay;\n\t\t\tenvRay.origin = rayOrigin;\n\t\t\tenvRay.direction = envDirection;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tenvPdf /= lightsDenom;\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\n\t\t// See issue #470\n\t\treturn result;\n\n\t}\n\n`;\n","export const stratifiedTextureGLSL = /* glsl */`\n\n\tuniform sampler2D stratifiedTexture;\n\tuniform sampler2D stratifiedOffsetTexture;\n\n\tuint sobolPixelIndex = 0u;\n\tuint sobolPathIndex = 0u;\n\tuint sobolBounceIndex = 0u;\n\tvec4 pixelSeed = vec4( 0 );\n\n\tvec4 rand4( int v ) {\n\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\n\n\t}\n\n\tvec3 rand3( int v ) {\n\n\t\treturn rand4( v ).xyz;\n\n\t}\n\n\tvec2 rand2( int v ) {\n\n\t\treturn rand4( v ).xy;\n\n\t}\n\n\tfloat rand( int v ) {\n\n\t\treturn rand4( v ).x;\n\n\t}\n\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\n\n\t\t// tile the small noise texture across the entire screen\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\n\t\tpixelSeed = texelFetch( stratifiedOffsetTexture, ivec2( screenCoord.xy ) % noiseSize, 0 );\n\n\t}\n\n`;\n","// Stratified Sampling based on implementation from hoverinc pathtracer\n// - https://github.com/hoverinc/ray-tracing-renderer\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\n\nexport function shuffle( arr ) {\n\n\tfor ( let i = arr.length - 1; i > 0; i -- ) {\n\n\t  const j = Math.floor( Math.random() * ( i + 1 ) );\n\t  const x = arr[ i ];\n\t  arr[ i ] = arr[ j ];\n\t  arr[ j ] = x;\n\n\t}\n\n\treturn arr;\n\n}\n\n// strataCount : The number of bins per dimension\n// dimensions  : The number of dimensions to generate stratified values for\nexport class StratifiedSampler {\n\n\tconstructor( strataCount, dimensions ) {\n\n\t\tconst l = strataCount ** dimensions;\n\t\tconst strata = new Uint16Array( l );\n\t\tlet index = l;\n\n\t\t// each integer represents a statum bin\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\tstrata[ i ] = i;\n\n\t\t}\n\n\t\tthis.samples = new Float32Array( dimensions );\n\n\t\tthis.strataCount = strataCount;\n\n\t\tthis.restart = function () {\n\n\t\t\tindex = 0;\n\n\t\t};\n\n\t\tthis.next = function () {\n\n\t\t\tconst { samples } = this;\n\n\t\t\tif ( index >= strata.length ) {\n\n\t\t\t\tshuffle( strata );\n\t\t\t\tthis.restart();\n\n\t\t\t}\n\n\t\t\tlet stratum = strata[ index ++ ];\n\n\t\t\tfor ( let i = 0; i < dimensions; i ++ ) {\n\n\t\t\t\tsamples[ i ] = ( stratum % strataCount + Math.random() ) / strataCount;\n\t\t\t\tstratum = Math.floor( stratum / strataCount );\n\n\t\t\t}\n\n\t\t\treturn samples;\n\n\t\t};\n\n\t}\n\n}\n","// Stratified Sampling based on implementation from hoverinc pathtracer\n// - https://github.com/hoverinc/ray-tracing-renderer\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\n\nimport { StratifiedSampler } from './StratifiedSampler.js';\n\n// Stratified set of data with each tuple stratified separately and combined\nexport class StratifiedSamplerCombined {\n\n\tconstructor( strataCount, listOfDimensions ) {\n\n\t\tlet totalDim = 0;\n\t\tfor ( const dim of listOfDimensions ) {\n\n\t\t\ttotalDim += dim;\n\n\t\t}\n\n\t\tconst combined = new Float32Array( totalDim );\n\t\tconst strataObjs = [];\n\t\tlet offset = 0;\n\t\tfor ( const dim of listOfDimensions ) {\n\n\t\t\tconst sampler = new StratifiedSampler( strataCount, dim );\n\t\t\tsampler.samples = new Float32Array( combined.buffer, offset, sampler.samples.length );\n\t\t\toffset += sampler.samples.length * 4;\n\t\t\tstrataObjs.push( sampler );\n\n\t\t}\n\n\t\tthis.samples = combined;\n\n\t\tthis.strataCount = strataCount;\n\n\t\tthis.next = function () {\n\n\t\t\tfor ( const strata of strataObjs ) {\n\n\t\t\t\tstrata.next();\n\n\t\t\t}\n\n\t\t\treturn combined;\n\n\t\t};\n\n\t\tthis.restart = function () {\n\n\t\t\tfor ( const strata of strataObjs ) {\n\n\t\t\t\tstrata.restart();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat } from 'three';\nimport { StratifiedSamplerCombined } from './stratified/StratifiedSamplerCombined.js';\n\nexport class StratifiedSamplesTexture extends DataTexture {\n\n\tconstructor( count = 1, depth = 1, strata = 8 ) {\n\n\t\tsuper( new Float32Array( 1 ), 1, 1, RGBAFormat, FloatType );\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\n\t\tthis.strata = strata;\n\t\tthis.sampler = null;\n\n\t\tthis.init( count, depth, strata );\n\n\t}\n\n\tinit( count, depth, strata = this.strata ) {\n\n\t\tconst { image } = this;\n\t\tif ( image.width === depth && image.height === count ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst dimensions = new Array( count * depth ).fill( 4 );\n\t\tconst sampler = new StratifiedSamplerCombined( strata, dimensions );\n\n\t\timage.width = depth;\n\t\timage.height = count;\n\t\timage.data = sampler.samples;\n\n\t\tthis.sampler = sampler;\n\n\t\tthis.dispose();\n\t\tthis.next();\n\n\t}\n\n\tnext() {\n\n\t\tthis.sampler.next();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n","export function shuffleArray( array, random = Math.random ) {\n\n\tfor ( let i = array.length - 1; i > 0; i -- ) {\n\n\t\tconst replaceIndex = ~ ~ ( ( random() - 1e-6 ) * i );\n\t\tconst tmp = array[ i ];\n\t\tarray[ i ] = array[ replaceIndex ];\n\t\tarray[ replaceIndex ] = tmp;\n\n\t}\n\n}\n\nexport function fillWithOnes( array, count ) {\n\n\tarray.fill( 0 );\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tarray[ i ] = 1;\n\n\t}\n\n}\n","export class BlueNoiseSamples {\n\n\tconstructor( size ) {\n\n\t\tthis.count = 0;\n\t\tthis.size = - 1;\n\t\tthis.sigma = - 1;\n\t\tthis.radius = - 1;\n\t\tthis.lookupTable = null;\n\t\tthis.score = null;\n\t\tthis.binaryPattern = null;\n\n\t\tthis.resize( size );\n\t\tthis.setSigma( 1.5 );\n\n\t}\n\n\tfindVoid() {\n\n\t\tconst { score, binaryPattern } = this;\n\n\t\tlet currValue = Infinity;\n\t\tlet currIndex = - 1;\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\n\n\t\t\tif ( binaryPattern[ i ] !== 0 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst pScore = score[ i ];\n\t\t\tif ( pScore < currValue ) {\n\n\t\t\t\tcurrValue = pScore;\n\t\t\t\tcurrIndex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn currIndex;\n\n\t}\n\n\tfindCluster() {\n\n\t\tconst { score, binaryPattern } = this;\n\n\t\tlet currValue = - Infinity;\n\t\tlet currIndex = - 1;\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\n\n\t\t\tif ( binaryPattern[ i ] !== 1 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst pScore = score[ i ];\n\t\t\tif ( pScore > currValue ) {\n\n\t\t\t\tcurrValue = pScore;\n\t\t\t\tcurrIndex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn currIndex;\n\n\t}\n\n\tsetSigma( sigma ) {\n\n\t\tif ( sigma === this.sigma ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// generate a radius in which the score will be updated under the\n\t\t// assumption that e^-10 is insignificant enough to be the border at\n\t\t// which we drop off.\n\t\tconst radius = ~ ~ ( Math.sqrt( 10 * 2 * ( sigma ** 2 ) ) + 1 );\n\t\tconst lookupWidth = 2 * radius + 1;\n\t\tconst lookupTable = new Float32Array( lookupWidth * lookupWidth );\n\t\tconst sigma2 = sigma * sigma;\n\t\tfor ( let x = - radius; x <= radius; x ++ ) {\n\n\t\t\tfor ( let y = - radius; y <= radius; y ++ ) {\n\n\t\t\t\tconst index = ( radius + y ) * lookupWidth + x + radius;\n\t\t\t\tconst dist2 = x * x + y * y;\n\t\t\t\tlookupTable[ index ] = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.lookupTable = lookupTable;\n\t\tthis.sigma = sigma;\n\t\tthis.radius = radius;\n\n\t}\n\n\tresize( size ) {\n\n\t\tif ( this.size !== size ) {\n\n\t\t\tthis.size = size;\n\t\t\tthis.score = new Float32Array( size * size );\n\t\t\tthis.binaryPattern = new Uint8Array( size * size );\n\n\t\t}\n\n\n\t}\n\n\tinvert() {\n\n\t\tconst { binaryPattern, score, size } = this;\n\n\t\tscore.fill( 0 );\n\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\n\n\t\t\tif ( binaryPattern[ i ] === 0 ) {\n\n\t\t\t\tconst y = ~ ~ ( i / size );\n\t\t\t\tconst x = i - y * size;\n\t\t\t\tthis.updateScore( x, y, 1 );\n\t\t\t\tbinaryPattern[ i ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tbinaryPattern[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateScore( x, y, multiplier ) {\n\n\t\t// TODO: Is there a way to keep track of the highest and lowest scores here to avoid have to search over\n\t\t// everything in the buffer?\n\t\tconst { size, score, lookupTable } = this;\n\n\t\t// const sigma2 = sigma * sigma;\n\t\t// const radius = Math.floor( size / 2 );\n\t\tconst radius = this.radius;\n\t\tconst lookupWidth = 2 * radius + 1;\n\t\tfor ( let px = - radius; px <= radius; px ++ ) {\n\n\t\t\tfor ( let py = - radius; py <= radius; py ++ ) {\n\n\t\t\t\t// const dist2 = px * px + py * py;\n\t\t\t\t// const value = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\n\n\t\t\t\tconst lookupIndex = ( radius + py ) * lookupWidth + px + radius;\n\t\t\t\tconst value = lookupTable[ lookupIndex ];\n\n\t\t\t\tlet sx = ( x + px );\n\t\t\t\tsx = sx < 0 ? size + sx : sx % size;\n\n\t\t\t\tlet sy = ( y + py );\n\t\t\t\tsy = sy < 0 ? size + sy : sy % size;\n\n\t\t\t\tconst sindex = sy * size + sx;\n\t\t\t\tscore[ sindex ] += multiplier * value;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddPointIndex( index ) {\n\n\t\tthis.binaryPattern[ index ] = 1;\n\n\t\tconst size = this.size;\n\t\tconst y = ~ ~ ( index / size );\n\t\tconst x = index - y * size;\n\t\tthis.updateScore( x, y, 1 );\n\t\tthis.count ++;\n\n\t}\n\n\tremovePointIndex( index ) {\n\n\t\tthis.binaryPattern[ index ] = 0;\n\n\t\tconst size = this.size;\n\t\tconst y = ~ ~ ( index / size );\n\t\tconst x = index - y * size;\n\t\tthis.updateScore( x, y, - 1 );\n\t\tthis.count --;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.resize( source.size );\n\t\tthis.score.set( source.score );\n\t\tthis.binaryPattern.set( source.binaryPattern );\n\t\tthis.setSigma( source.sigma );\n\t\tthis.count = source.count;\n\n\t}\n\n}\n","import { shuffleArray, fillWithOnes } from './utils.js';\nimport { BlueNoiseSamples } from './BlueNoiseSamples.js';\n\nexport class BlueNoiseGenerator {\n\n\tconstructor() {\n\n\t\tthis.random = Math.random;\n\t\tthis.sigma = 1.5;\n\t\tthis.size = 64;\n\t\tthis.majorityPointsRatio = 0.1;\n\n\t\tthis.samples = new BlueNoiseSamples( 1 );\n\t\tthis.savedSamples = new BlueNoiseSamples( 1 );\n\n\t}\n\n\tgenerate() {\n\n\t\t// http://cv.ulichney.com/papers/1993-void-cluster.pdf\n\n\t\tconst {\n\t\t\tsamples,\n\t\t\tsavedSamples,\n\t\t\tsigma,\n\t\t\tmajorityPointsRatio,\n\t\t\tsize,\n\t\t} = this;\n\n\t\tsamples.resize( size );\n\t\tsamples.setSigma( sigma );\n\n\t\t// 1. Randomly place the minority points.\n\t\tconst pointCount = Math.floor( size * size * majorityPointsRatio );\n\t\tconst initialSamples = samples.binaryPattern;\n\n\t\tfillWithOnes( initialSamples, pointCount );\n\t\tshuffleArray( initialSamples, this.random );\n\n\t\tfor ( let i = 0, l = initialSamples.length; i < l; i ++ ) {\n\n\t\t\tif ( initialSamples[ i ] === 1 ) {\n\n\t\t\t\tsamples.addPointIndex( i );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 2. Remove minority point that is in densest cluster and place it in the largest void.\n\t\twhile ( true ) {\n\n\t\t\tconst clusterIndex = samples.findCluster();\n\t\t\tsamples.removePointIndex( clusterIndex );\n\n\t\t\tconst voidIndex = samples.findVoid();\n\t\t\tif ( clusterIndex === voidIndex ) {\n\n\t\t\t\tsamples.addPointIndex( clusterIndex );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tsamples.addPointIndex( voidIndex );\n\n\t\t}\n\n\t\t// 3. PHASE I: Assign a rank to each progressively less dense cluster point and put it\n\t\t// in the dither array.\n\t\tconst ditherArray = new Uint32Array( size * size );\n\t\tsavedSamples.copy( samples );\n\n\t\tlet rank;\n\t\trank = samples.count - 1;\n\t\twhile ( rank >= 0 ) {\n\n\t\t\tconst clusterIndex = samples.findCluster();\n\t\t\tsamples.removePointIndex( clusterIndex );\n\n\t\t\tditherArray[ clusterIndex ] = rank;\n\t\t\trank --;\n\n\t\t}\n\n\t\t// 4. PHASE II: Do the same thing for the largest voids up to half of the total pixels using\n\t\t// the initial binary pattern.\n\t\tconst totalSize = size * size;\n\t\trank = savedSamples.count;\n\t\twhile ( rank < totalSize / 2 ) {\n\n\t\t\tconst voidIndex = savedSamples.findVoid();\n\t\t\tsavedSamples.addPointIndex( voidIndex );\n\t\t\tditherArray[ voidIndex ] = rank;\n\t\t\trank ++;\n\n\t\t}\n\n\t\t// 5. PHASE III: Invert the pattern and finish out by assigning a rank to the remaining\n\t\t// and iteratively removing them.\n\t\tsavedSamples.invert();\n\n\t\twhile ( rank < totalSize ) {\n\n\t\t\tconst clusterIndex = savedSamples.findCluster();\n\t\t\tsavedSamples.removePointIndex( clusterIndex );\n\t\t\tditherArray[ clusterIndex ] = rank;\n\t\t\trank ++;\n\n\t\t}\n\n\t\treturn { data: ditherArray, maxValue: totalSize };\n\n\t}\n\n}\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat, RGFormat, RedFormat } from 'three';\nimport { BlueNoiseGenerator } from './blueNoise/BlueNoiseGenerator.js';\n\nfunction getStride( channels ) {\n\n\tif ( channels >= 3 ) {\n\n\t\treturn 4;\n\n\t} else {\n\n\t\treturn channels;\n\n\t}\n\n}\n\nfunction getFormat( channels ) {\n\n\tswitch ( channels ) {\n\n\tcase 1:\n\t\treturn RedFormat;\n\tcase 2:\n\t\treturn RGFormat;\n\tdefault:\n\t\treturn RGBAFormat;\n\n\t}\n\n}\n\nexport class BlueNoiseTexture extends DataTexture {\n\n\tconstructor( size = 64, channels = 1 ) {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1, RGBAFormat, FloatType );\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\n\t\tthis.size = size;\n\t\tthis.channels = channels;\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst channels = this.channels;\n\t\tconst size = this.size;\n\t\tconst generator = new BlueNoiseGenerator();\n\t\tgenerator.channels = channels;\n\t\tgenerator.size = size;\n\n\t\tconst stride = getStride( channels );\n\t\tconst format = getFormat( stride );\n\t\tif ( this.image.width !== size || format !== this.format ) {\n\n\t\t\tthis.image.width = size;\n\t\t\tthis.image.height = size;\n\t\t\tthis.image.data = new Float32Array( ( size ** 2 ) * stride );\n\t\t\tthis.format = format;\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tconst data = this.image.data;\n\t\tfor ( let i = 0, l = channels; i < l; i ++ ) {\n\n\t\t\tconst result = generator.generate();\n\t\t\tconst bin = result.data;\n\t\t\tconst maxValue = result.maxValue;\n\n\t\t\tfor ( let j = 0, l2 = bin.length; j < l2; j ++ ) {\n\n\t\t\t\tconst value = bin[ j ] / maxValue;\n\t\t\t\tdata[ j * stride + i ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n","import { Matrix4, Vector2 } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\nimport {\n\tMeshBVHUniformStruct, UIntVertexAttributeTexture,\n\tBVHShaderGLSL,\n} from 'three-mesh-bvh';\n\n// uniforms\nimport { PhysicalCameraUniform } from '../../uniforms/PhysicalCameraUniform.js';\nimport { EquirectHdrInfoUniform } from '../../uniforms/EquirectHdrInfoUniform.js';\nimport { LightsInfoUniformStruct } from '../../uniforms/LightsInfoUniformStruct.js';\nimport { IESProfilesTexture } from '../../uniforms/IESProfilesTexture.js';\nimport { AttributesTextureArray } from '../../uniforms/AttributesTextureArray.js';\nimport { MaterialsTexture } from '../../uniforms/MaterialsTexture.js';\nimport { RenderTarget2DArray } from '../../uniforms/RenderTarget2DArray.js';\n\n// glsl\nimport { cameraStructGLSL } from '../../shader/structs/cameraStruct.glsl.js';\nimport { equirectStructGLSL } from '../../shader/structs/equirectStruct.glsl.js';\nimport { lightsStructGLSL } from '../../shader/structs/lightsStruct.glsl.js';\nimport { materialStructGLSL } from '../../shader/structs/materialStruct.glsl.js';\nimport { fogMaterialBvhGLSL } from '../../shader/structs/fogMaterialBvh.glsl.js';\n\n// material sampling\nimport { bsdfSamplingGLSL } from '../../shader/bsdf/bsdfSampling.glsl.js';\nimport { fogGLSL } from '../../shader/bsdf/fog.glsl.js';\n\n// sampling\nimport { equirectSamplingGLSL } from '../../shader/sampling/equirectSampling.glsl.js';\nimport { lightSamplingGLSL } from '../../shader/sampling/lightSampling.glsl.js';\nimport { shapeSamplingGLSL } from '../../shader/sampling/shapeSampling.glsl.js';\n\n// common glsl\nimport { intersectShapesGLSL } from '../../shader/common/intersectShapes.glsl.js';\nimport { mathGLSL } from '../../shader/common/math.glsl.js';\nimport { utilsGLSL } from '../../shader/common/utils.glsl.js';\nimport { fresnelGLSL } from '../../shader/common/fresnel.glsl.js';\nimport { arraySamplerTexelFetchGLSL } from '../../shader/common/arraySamplerTexelFetch.glsl.js';\n\n// random glsl\nimport { pcgGLSL } from '../../shader/rand/pcg.glsl.js';\nimport { sobolCommonGLSL, sobolSamplingGLSL } from '../../shader/rand/sobol.glsl.js';\n\n// path tracer utils\nimport { renderStructsGLSL } from './glsl/renderStructs.glsl.js';\nimport { cameraUtilsGLSL } from './glsl/cameraUtils.glsl.js';\nimport { attenuateHitGLSL } from './glsl/attenuateHit.glsl.js';\nimport { traceSceneGLSL } from './glsl/traceScene.glsl.js';\nimport { getSurfaceRecordGLSL } from './glsl/getSurfaceRecord.glsl.js';\nimport { directLightContributionGLSL } from './glsl/directLightContribution.glsl.js';\nimport { stratifiedTextureGLSL } from '../../shader/rand/stratifiedTexture.glsl.js';\nimport { StratifiedSamplesTexture } from '../../uniforms/StratifiedSamplesTexture.js';\nimport { BlueNoiseTexture } from '../../textures/BlueNoiseTexture.js';\n\nexport class PhysicalPathTracingMaterial extends MaterialBase {\n\n\tonBeforeRender() {\n\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\n\t\tthis.setDefine( 'FEATURE_BACKGROUND_MAP', this.backgroundMap ? 1 : 0 );\n\t\tthis.setDefine( 'FEATURE_FOG', this.materials.features.isUsed( 'FOG' ) ? 1 : 0 );\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t\tdefines: {\n\t\t\t\tFEATURE_MIS: 1,\n\t\t\t\tFEATURE_RUSSIAN_ROULETTE: 1,\n\t\t\t\tFEATURE_DOF: 1,\n\t\t\t\tFEATURE_BACKGROUND_MAP: 0,\n\t\t\t\tFEATURE_FOG: 1,\n\n\t\t\t\t// 0 = PCG\n\t\t\t\t// 1 = Sobol\n\t\t\t\t// 2 = Stratified List\n\t\t\t\tRANDOM_TYPE: 2,\n\n\t\t\t\t// 0 = Perspective\n\t\t\t\t// 1 = Orthographic\n\t\t\t\t// 2 = Equirectangular\n\t\t\t\tCAMERA_TYPE: 0,\n\n\t\t\t\tDEBUG_MODE: 0,\n\n\t\t\t\tATTR_NORMAL: 0,\n\t\t\t\tATTR_TANGENT: 1,\n\t\t\t\tATTR_UV: 2,\n\t\t\t\tATTR_COLOR: 3,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t\tbounces: { value: 10 },\n\t\t\t\ttransmissiveBounces: { value: 10 },\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\n\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tattributesArray: { value: new AttributesTextureArray() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tlights: { value: new LightsInfoUniformStruct() },\n\t\t\t\tiesProfiles: { value: new IESProfilesTexture().texture },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tbackgroundBlur: { value: 0.0 },\n\t\t\t\tenvironmentIntensity: { value: 1.0 },\n\t\t\t\tenvironmentRotation: { value: new Matrix4() },\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\n\t\t\t\tbackgroundMap: { value: null },\n\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tfilterGlossyFactor: { value: 0.0 },\n\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\n\t\t\t\tsobolTexture: { value: null },\n\t\t\t\tstratifiedTexture: { value: new StratifiedSamplesTexture() },\n\t\t\t\tstratifiedOffsetTexture: { value: new BlueNoiseTexture( 64, 1 ) },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\t\t\t\t#define INFINITY 1e20\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t// bvh intersection\n\t\t\t\t${ BVHShaderGLSL.common_functions }\n\t\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\n\t\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\n\n\t\t\t\t// uniform structs\n\t\t\t\t${ cameraStructGLSL }\n\t\t\t\t${ lightsStructGLSL }\n\t\t\t\t${ equirectStructGLSL }\n\t\t\t\t${ materialStructGLSL }\n\n\t\t\t\t// random\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\n\n\t\t\t\t\t${ stratifiedTextureGLSL }\n\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\n\n\t\t\t\t\t${ pcgGLSL }\n\t\t\t\t\t${ sobolCommonGLSL }\n\t\t\t\t\t${ sobolSamplingGLSL }\n\n\t\t\t\t\t#define rand(v) sobol(v)\n\t\t\t\t\t#define rand2(v) sobol2(v)\n\t\t\t\t\t#define rand3(v) sobol3(v)\n\t\t\t\t\t#define rand4(v) sobol4(v)\n\n\t\t\t\t#else \t\t\t\t\t// PCG\n\n\t\t\t\t\t${ pcgGLSL }\n\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\n\t\t\t\t\t// - specifically the \"sobolReverseBits\" function.\n\t\t\t\t\tuint sobolPixelIndex = 0u;\n\t\t\t\t\tuint sobolPathIndex = 0u;\n\t\t\t\t\tuint sobolBounceIndex = 0u;\n\n\t\t\t\t\t#define rand(v) pcgRand()\n\t\t\t\t\t#define rand2(v) pcgRand2()\n\t\t\t\t\t#define rand3(v) pcgRand3()\n\t\t\t\t\t#define rand4(v) pcgRand4()\n\n\t\t\t\t#endif\n\n\t\t\t\t// common\n\t\t\t\t${ arraySamplerTexelFetchGLSL }\n\t\t\t\t${ fresnelGLSL }\n\t\t\t\t${ utilsGLSL }\n\t\t\t\t${ mathGLSL }\n\t\t\t\t${ intersectShapesGLSL }\n\n\t\t\t\t// environment\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float environmentIntensity;\n\n\t\t\t\t// lighting\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\t\t\t\tuniform LightsInfo lights;\n\n\t\t\t\t// background\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\n\t\t\t\t#endif\n\n\t\t\t\t// camera\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\t// geometry\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tuniform BVH bvh;\n\n\t\t\t\t// path tracer\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform int transmissiveBounces;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\n\t\t\t\t// image\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t// globals\n\t\t\t\tmat3 envRotation3x3;\n\t\t\t\tmat3 invEnvRotation3x3;\n\t\t\t\tfloat lightsDenom;\n\n\t\t\t\t// sampling\n\t\t\t\t${ fogMaterialBvhGLSL }\n\t\t\t\t${ shapeSamplingGLSL }\n\t\t\t\t${ bsdfSamplingGLSL }\n\t\t\t\t${ equirectSamplingGLSL }\n\t\t\t\t${ lightSamplingGLSL }\n\t\t\t\t${ fogGLSL }\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur );\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\treturn sampleEquirectColor( backgroundMap, sampleDir );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t${ renderStructsGLSL }\n\t\t\t\t${ cameraUtilsGLSL }\n\t\t\t\t${ traceSceneGLSL }\n\t\t\t\t${ attenuateHitGLSL }\n\t\t\t\t${ directLightContributionGLSL }\n\t\t\t\t${ getSurfaceRecordGLSL }\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// init\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\t// get camera ray\n\t\t\t\t\tRay ray = getCameraRay();\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\n\t\t\t\t\tlightsDenom =\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\n\t\t\t\t\t\t\tfloat( lights.count ) :\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\n\n\t\t\t\t\t// surface results\n\t\t\t\t\tSurfaceHit surfaceHit;\n\t\t\t\t\tScatterRecord scatterRec;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tRenderState state = initRenderState();\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\n\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\n\t\t\t\t\t\tray.origin, - ray.direction,\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\n\t\t\t\t\t\tstate.fogMaterial\n\t\t\t\t\t);\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tstate.depth ++;\n\t\t\t\t\t\tstate.traversals = bounces - i;\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\n\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\n\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\n\n\t\t\t\t\t\t\tLightRecord lightRec;\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\n\t\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( envRotation3x3 * ray.direction, rand2( 2 ) ) * state.throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\n\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\n\n\t\t\t\t\t\t\tstate.fogMaterial = material;\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// early out if this is a matte material\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRecord surf;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetSurfaceRecord(\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\n\t\t\t\t\t\t\t\tsurf\n\t\t\t\t\t\t\t) == SKIP_SURFACE\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\n\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t// next event estimation\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate emissive color\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\n\t\t\t\t\t\t// perform this separate from a bounce\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\n\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\n\t\t\t\t\t\t\ti --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// handle throughput color transformation\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\n\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\n\n\t\t\t\t\t\t// russian roulette path termination\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\n\t\t\t\t\t\tuint minBounces = 3u;\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\n\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\n\t\t\t\t\t\trrProb = sqrt( rrProb );\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// prepare for next ray\n\t\t\t\t\t\tray.direction = scatterRec.direction;\n\t\t\t\t\t\tray.origin = hitPoint;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t\t#if DEBUG_MODE == 1\n\n\t\t\t\t\t// output the number of rays checked in the path and number of\n\t\t\t\t\t// transmissive rays encountered.\n\t\t\t\t\tgl_FragColor.rgb = vec3(\n\t\t\t\t\t\tfloat( state.depth ),\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\n\t\t\t\t\t\t0.0\n\t\t\t\t\t);\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { Color, MeshStandardMaterial } from 'three';\n\nexport class FogVolumeMaterial extends MeshStandardMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( params );\n\n\t\tthis.isFogVolumeMaterial = true;\n\n\t\tthis.density = 0.015;\n\t\tthis.emissive = new Color();\n\t\tthis.emissiveIntensity = 0.0;\n\t\tthis.opacity = 0.15;\n\t\tthis.transparent = true;\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { MaterialBase } from '../materials/MaterialBase.js';\n\nconst computePrecisionFunction = /* glsl */`\n    precision highp float;\n    precision highp int;\n    struct FloatStruct {\n        highp float value;\n    };\n\n    struct IntStruct {\n        highp int value;\n    };\n\n    struct UintStruct {\n        highp uint value;\n    };\n\n    vec2 computePrecision() {\n\n        #if MODE == 0 // float\n\n            float exponent = 0.0;\n            float value = 1.5;\n            while ( value > 1.0 ) {\n\n                exponent ++;\n                value = 1.0 + pow( 2.0, - exponent ) / 2.0;\n\n            }\n\n            float structExponent = 0.0;\n            FloatStruct str;\n            str.value = 1.5;\n            while ( str.value > 1.0 ) {\n\n                structExponent ++;\n                str.value = 1.0 + pow( 2.0, - structExponent ) / 2.0;\n\n            }\n\n            return vec2( exponent, structExponent );\n\n\n        #elif MODE == 1 // int\n\n            int bits = 0;\n            int value = 1;\n            while ( value > 0 ) {\n\n                value = value << 1;\n                value = value | 1;\n                bits ++;\n\n            }\n\n            int structBits = 0;\n            IntStruct str;\n            str.value = 1;\n            while ( str.value > 0 ) {\n\n                str.value = str.value << 1;\n                str.value = str.value | 1;\n                structBits ++;\n\n            }\n\n            return vec2( bits, structBits );\n\n        #else // uint\n\n            int bits = 0;\n            uint value = 1u;\n            while ( value > 0u ) {\n\n                value = value << 1u;\n                bits ++;\n\n            }\n\n            int structBits = 0;\n            UintStruct str;\n            str.value = 1u;\n            while( str.value > 0u ) {\n\n                str.value = str.value << 1u;\n                structBits ++;\n\n            }\n\n            return vec2( bits, structBits );\n\n        #endif\n\n    }\n\n\n`;\n\nexport class PrecisionMaterial extends MaterialBase {\n\n\tset mode( v ) {\n\n\t\tthis._mode = v;\n\n\t\tswitch ( v.toLowerCase() ) {\n\n\t\tcase 'float':\n\t\t\tthis.setDefine( 'MODE', 0 );\n\t\t\tbreak;\n\t\tcase 'int':\n\t\t\tthis.setDefine( 'MODE', 1 );\n\t\t\tbreak;\n\t\tcase 'uint':\n\t\t\tthis.setDefine( 'MODE', 2 );\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\t${ computePrecisionFunction }\n\n\t\t\t\tvarying vec2 vPrecision;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvPrecision = computePrecision();\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t${ computePrecisionFunction }\n\n\t\t\t\tvarying vec2 vPrecision;\n\t\t\t\tvoid main( void ) {\n\n\t\t\t\t\tvec2 fPrecision = computePrecision();\n\t\t\t\t\tgl_FragColor = vec4( vPrecision, fPrecision ) / 255.0;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n","import { WebGLRenderTarget } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { PrecisionMaterial } from './PrecisionMaterial.js';\n\n// see https://github.com/gkjohnson/webgl-precision\n// Returns whether the platform can use highp precision consistently in structs\nexport class PrecisionDetector {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._result = null;\n\n\t}\n\n\tdetect() {\n\n\t\tif ( this._result ) {\n\n\t\t\treturn this._result;\n\n\t\t}\n\n\t\tconst renderer = this._renderer;\n\t\tconst material = new PrecisionMaterial();\n\t\tconst quad = new FullScreenQuad( material );\n\t\tconst target = new WebGLRenderTarget( 1, 1 );\n\t\tconst ogTarget = renderer.getRenderTarget();\n\n\t\tconst detail = {\n\t\t\t'int': extractResult( 'int' ),\n\t\t\t'uint': extractResult( 'uint' ),\n\t\t\t'float': extractResult( 'float' ),\n\t\t};\n\n\t\tconst message = doesPass( 'int', detail.int ) || doesPass( 'uint', detail.uint ) || doesPass( 'float', detail.float );\n\t\tthis._result = {\n\t\t\tdetail,\n\t\t\tmessage,\n\t\t\tpass: ! Boolean( message ),\n\t\t};\n\n\t\trenderer.setRenderTarget( ogTarget );\n\t\tquad.dispose();\n\t\ttarget.dispose();\n\t\tmaterial.dispose();\n\t\treturn this._result;\n\n\t\tfunction doesPass( type, info ) {\n\n\t\t\tif ( info.vertex === info.vertexStruct && info.fragment === info.fragmentStruct ) {\n\n\t\t\t\treturn '';\n\n\t\t\t} else {\n\n\t\t\t\treturn `Type \"${ type }\" cannot correctly provide highp precision in structs.`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction extractResult( mode ) {\n\n\t\t\tmaterial.mode = mode;\n\t\t\trenderer.setRenderTarget( target );\n\t\t\tquad.render( renderer );\n\n\t\t\tconst readBuffer = new Uint8Array( 4 );\n\t\t\trenderer.readRenderTargetPixels( target, 0, 0, 1, 1, readBuffer );\n\n\t\t\treturn {\n\n\t\t\t\tvertex: readBuffer[ 0 ],\n\t\t\t\tvertexStruct: readBuffer[ 1 ],\n\t\t\t\tfragment: readBuffer[ 2 ],\n\t\t\t\tfragmentStruct: readBuffer[ 3 ],\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, BoxGeometry, PerspectiveCamera } from 'three';\n\n// Returns whether a material can be compiled and run on the current device or not\nexport class MaterialCompileDetector {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\n\t}\n\n\tdetect( material ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst mesh = new Mesh( new BoxGeometry(), material );\n\t\tconst camera = new PerspectiveCamera();\n\t\tconst ogShaderErrors = renderer.debug.checkShaderErrors;\n\t\trenderer.debug.checkShaderErrors = true;\n\n\t\tconst programs = renderer.info.programs;\n\t\tconst progLength = programs.length;\n\t\trenderer.compile( mesh, camera );\n\n\t\trenderer.debug.checkShaderErrors = ogShaderErrors;\n\t\tmesh.geometry.dispose();\n\n\t\tif ( programs.length === progLength ) {\n\n\t\t\treturn {\n\t\t\t\tdetail: null,\n\t\t\t\tpass: true,\n\t\t\t\tmessage: 'Cannot determine shader compilation status if material has already been used.',\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst program = programs[ programs.length - 1 ];\n\t\t\tconst pass = program.diagnostics ? program.diagnostics.runnable : true;\n\t\t\tconst message = pass ? '' : `Cannot render ${ material.type } on this device.`;\n\t\t\treturn {\n\t\t\t\tdetail: {},\n\t\t\t\tpass,\n\t\t\t\tmessage,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n","import { PrecisionDetector } from './PrecisionDetector.js';\nimport { MaterialCompileDetector } from './MaterialCompileDetector.js';\nexport class CompatibilityDetector {\n\n\tconstructor( renderer, material ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._material = material;\n\n\t}\n\n\tdetect() {\n\n\t\tlet detector = new PrecisionDetector( this._renderer );\n\t\tlet result = detector.detect();\n\t\tif ( ! result.pass ) {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tdetector = new MaterialCompileDetector( this._renderer );\n\t\tresult = detector.detect( this._material );\n\t\tif ( ! result.pass ) {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdetail: {},\n\t\t\tpass: true,\n\t\t\tmessage: '',\n\t\t};\n\n\t}\n\n}\n","// core\nexport * from './core/PathTracingRenderer.js';\nexport * from './core/QuiltPathTracingRenderer.js';\nexport * from './core/PathTracingSceneGenerator.js';\nexport * from './core/DynamicPathTracingSceneGenerator.js';\nexport * from './core/MaterialReducer.js';\n\n// objects\nexport * from './objects/PhysicalCamera.js';\nexport * from './objects/EquirectCamera.js';\nexport * from './objects/PhysicalSpotLight.js';\nexport * from './objects/ShapedAreaLight.js';\n\n// textures\nexport * from './textures/ProceduralEquirectTexture.js';\nexport * from './textures/GradientEquirectTexture.js';\n\n// uniforms\nexport * from './uniforms/MaterialsTexture.js';\nexport * from './uniforms/RenderTarget2DArray.js';\nexport * from './uniforms/EquirectHdrInfoUniform.js';\nexport * from './uniforms/PhysicalCameraUniform.js';\nexport * from './uniforms/LightsInfoUniformStruct.js';\nexport * from './uniforms/IESProfilesTexture.js';\n\n// utils\nexport * from './utils/GeometryPreparationUtils.js';\nexport * from './utils/BlurredEnvMapGenerator.js';\nexport * from './utils/IESLoader.js';\n\n// materials\nexport * from './materials/fullscreen/DenoiseMaterial.js';\nexport * from './materials/fullscreen/GradientMapMaterial.js';\nexport * from './materials/debug/GraphMaterial.js';\nexport * from './materials/MaterialBase.js';\nexport * from './materials/pathtracing/PhysicalPathTracingMaterial.js';\nexport * from './materials/surface/FogVolumeMaterial.js';\n\n// detectors\nexport * from './detectors/CompatibilityDetector.js';\n"],"names":["prevColor"],"mappings":"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E,EAAE;AACxC,CAAC,GAAG,6BAA6B,EAAE,CAAC,EAAE,EAAE;AACxC,CAAC,GAAG,6BAA6B,EAAE,CAAC,EAAE,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC;AACF;AACO,MAAM,mBAAmB,aAAa,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC;AACF;AACO,MAAM,iBAAiB,aAAa,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,4BAA4B,EAAE,CAAC,EAAE,EAAE;AACvC,CAAC,GAAG,4BAA4B,EAAE,CAAC,EAAE,EAAE;AACvC,CAAC,GAAG,4BAA4B,EAAE,CAAC,EAAE,EAAE;AACvC,CAAC,GAAG,4BAA4B,EAAE,CAAC,EAAE,EAAE;AACvC;AACA,CAAC;;AC1PD,MAAM,oBAAoB,SAAS,YAAY,CAAC;AAChD;AACA,CAAC,WAAW,GAAG;AACf;AACA,EAAE,KAAK,EAAE;AACT;AACA,GAAG,QAAQ,EAAE,UAAU;AACvB;AACA,GAAG,QAAQ,EAAE;AACb;AACA,IAAI,UAAU,EAAE,EAAE,KAAK,EAAE,IAAI,OA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AE,QAAQ,EAAE,CAAC,mBAAmB,EAAE;AAChD,KAAK,IAAI,KAAK,EAAE,QAAQ,EAAE,CAAC,mBAAmB,EAAE;AAChD,KAAK,IAAI,KAAK,EAAE,QAAQ,EAAE,CAAC,mBAAmB,EAAE;AAChD,KAAK,EAAE;AACP;AACA,IAAI;AACJ;AACA,GAAG,YAAY,YAAY,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,cAAc,YAAY,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,EAAE,CAAC;AACN;AACA;AACA,EAAE,IAAI,CAAC,qBAAqB,aAAa,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC;AACJ;AACA,EAAE,IAAI,CAAC,SAAS,EAAE,UAAU,EAAE,CAAC;AAC/B;AACA,EA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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACtFM,MAAM,kBAAkB,cAAc,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC/MM,MAAM,kBAAkB,aAAa,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC7DM,MAAM,OAAO,aAAa,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACrGM,MAAM,SAAS,aAAa,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACjGM,MAAM,eAAe,aAAa,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AClID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,gBAAgB,aAAa,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,OAAO,EAAE;AACb,CAAC,GAAG,SAAS,EAAE;AACf,CAAC,GAAG,eAAe,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACtfM,MAAM,OAAO,aAAa,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACrBM,MAAM,oBAAoB,aAAa,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACpEM,MAAM,iBAAiB,aAAa,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACvNM,MAAM,iBAAiB,aAAa,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACrFM,MAAM,mBAAmB,aAAa,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC7DM,MAAM,QAAQ,aAAa,CAAC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AChFM,MAAM,WAAW,aAAa,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACtGM,MAAM,0BAA0B,YAAY,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACxBM,MAAM,OAAO,aAAa,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACxDM,MAAM,iBAAiB,aAAa,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACjDM,MAAM,eAAe,aAAa,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACnFM,MAAM,gBAAgB,aAAa,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACjLM,MAAM,cAAc,aAAa,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AChDM,MAAM,oBAAoB,aAAa,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACnUM,MAAM,2BAA2B,WAAW,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AChGM,MAAM,qBAAqB,aAAa,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC5CD;AACA;AACA;AACA;AACO,SAAS,OAAO,EAAE,GAAG,GAAG;AAC/B;AACA,CAAC,MAAM,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG;AAC7C;AACA,GAAG,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,EAA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,gBAAgB,EAAE;AACzB,IAAI,GAAG,gBAAgB,EAAE;AACzB,IAAI,GAAG,kBAAkB,EAAE;AAC3B,IAAI,GAAG,kBAAkB,EAAE;AAC3B;AACA;AACA;AACA;AACA,KAAK,GAAG,qBAAqB,EAAE;AAC/B;AACA;AACA;AACA,KAAK,GAAG,OAAO,EAAE;AACjB,KAAK,GAAG,eAAe,EAAE;AACzB,KAAK,GAAG,iBAAiB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,OAAO,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,0BAA0B,EAAE;AACnC,IAAI,GAAG,WAAW,EAAE;AACpB,IAAI,GAAG,SAAS,EAAE;AAClB,IAAI,GAAG,QAAQ,EAAE;AACjB,IAAI,GAAG,mBAAmB,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,kBAAkB,EAAE;AAC3B,IAAI,GAAG,iBAAiB,EAAE;AAC1B,IAAI,GAAG,gBAAgB,EAAE;AACzB,IAAI,GAAG,oBAAoB,EAAE;AAC7B,IAAI,GAAG,iBAAiB,EAAE;AAC1B,IAAI,GAAG,OAAO,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,iBAAiB,EAAE;AAC1B,IAAI,GAAG,eAAe,EAAE;AACxB,IAAI,GAAG,cAAc,EAAE;AACvB,IAAI,GAAG,gBAAgB,EAAE;AACzB,IAAI,GAAG,2BAA2B,EAAE;AACpC,IAAI,GAAG,oBAAoB,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,EAAE,CAAC;AACN;AACA,EAAE,IAAI,CAAC,SAAS,EAAE,UAAU,EAAE,CAAC;AAC/B;AACA,EAAE;AACF;AACA;;ACllBO,MAAM,iBAAiB,SAAS,oBAAoB,CAAC;AAC5D;AACA,CAAC,WAAW,EAAE,MAAM,GAAG;AACvB;AACA,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC;AAClB;AACA,EAAE,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;AAClC;AACA,EAAE,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;AACvB,EAAE,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,EAAE,CAAC;AAC9B,EAAE,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC;AAC/B,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;AACtB,EAAE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;AAC1B,EAAE,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC;AACvB,EAAE,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC;AACvB;AACA,EAAE,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC;AAC3B;AACA,EAAE;AACF;AACA;;ACpBA,MAAM,wBAAwB,aAAa,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC;AACF;AACO,MAAM,iBAAiB,SAAS,YAAY,CAAC;AACpD;AACA,CAAC,IAAI,IAAI,EAAE,CAAC,GAAG;AACf;AACA,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;AACjB;AACA,EAAE,SAAS,CAAC,CAAC,WAAW,EAAE;AAC1B;AACA,EAAE,KAAK,OAAO;AACd,GAAG,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC;AAC/B,GAAG,MAAM;AACT,EAAE,KAAK,KAAK;AACZ,GAAG,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC;AAC/B,GAAG,MAAM;AACT,EAAE,KAAK,MAAM;AACb,GAAG,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC;AAC/B,GAAG,MAAM;AACT;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA,CAAC,WAAW,GAAG;AACf;AACA,EAAE,KAAK,EAAE;AACT;AACA,GAAG,YAAY,YAAY,CAAC;AAC5B;AACA,IAAI,GAAG,wBAAwB,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,cAAc,YAAY,CAAC;AAC9B;AACA,IAAI,GAAG,wBAAwB,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,EAAE,CAAC;AACN;AACA,EAAE;AACF;AACA;;AC3JA;AACA;AACO,MAAM,iBAAiB,CAAC;AAC/B;AACA,CAAC,WAAW,EAAE,QAAQ,GAAG;AACzB;AACA,EAA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"}