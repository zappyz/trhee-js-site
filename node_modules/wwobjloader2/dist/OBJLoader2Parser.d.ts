export type RawMeshType = {
    objectName: string;
    groupName: string;
    activeMtlName: string;
    mtllibName: string;
    faceType: number;
    subGroups: Map<string, RawMeshSubGroupType>;
    subGroupInUse: RawMeshSubGroupType | undefined;
    smoothingGroup: {
        splitMaterials: boolean;
        normalized: number;
        real: number;
    };
    counts: {
        doubleIndicesCount: number;
        faceCount: number;
        mtlCount: number;
        smoothingGroupCount: number;
    };
};
export type RawMeshSubGroupType = {
    index: string;
    objectName: string;
    groupName: string;
    materialName: string;
    smoothingGroup: number;
    vertices: number[];
    indexMappingsCount: 0;
    indexMappings: Map<string, number>;
    indices: number[];
    colors: number[];
    uvs: number[];
    normals: number[];
};
export type GlobalCountsType = {
    vertices: number;
    faces: number;
    doubleIndicesCount: number;
    lineByte: number;
    currentByte: number;
    totalBytes: number;
};
export type LoggingType = {
    enabled: boolean;
    debug: boolean;
};
export type MaterialMetaInfoType = {
    materialCloneInstructions: MaterialCloneInstructionType[];
    materialName: string;
    multiMaterialNames: Map<number, string>;
    modelName: string;
    geometryType: number;
};
export type MaterialCloneInstructionType = {
    materialNameOrg: string;
    materialProperties: {
        name: string;
        vertexColors: number;
        flatShading: boolean;
    };
};
export type RawMeshResultType = {
    name: string;
    subGroups: RawMeshSubGroupType[];
    absoluteVertexCount: number;
    absoluteIndexCount: number;
    absoluteColorCount: number;
    absoluteNormalCount: number;
    absoluteUvCount: number;
    faceCount: number;
    doubleIndicesCount: number;
};
export type PreparedMeshType = {
    meshName: string;
    vertexFA: Float32Array;
    normalFA: Float32Array | null;
    uvFA: Float32Array | null;
    colorFA: Float32Array | null;
    indexUA: Uint32Array | null;
    createMultiMaterial: boolean;
    geometryGroups: GeometryGroupType[];
    multiMaterial: string[];
    materialMetaInfo: MaterialMetaInfoType;
    progress: number;
};
export type GeometryGroupType = {
    materialGroupOffset: number;
    materialGroupLength: number;
    materialIndex: number;
};
export type BulkConfigType = {
    materialPerSmoothingGroup: boolean;
    useOAsMesh: boolean;
    useIndices: boolean;
    disregardNormals: boolean;
    modelName: string;
    materialNames: Set<string>;
};
export declare class OBJLoader2Parser {
    private logging;
    private usedBefore;
    private contentRef;
    private legacyMode;
    private materialNames;
    private modelName;
    private materialPerSmoothingGroup;
    private useOAsMesh;
    private useIndices;
    private disregardNormals;
    private vertices;
    private colors;
    private normals;
    private uvs;
    private rawMesh;
    private inputObjectCount;
    private outputObjectCount;
    private globalCounts;
    constructor();
    private buildDefaultLogging;
    private buildDefaultRawMesh;
    private buildDefaultGlobalsCount;
    setBulkConfig(config: BulkConfigType): void;
    /**
     * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
     *
     * @param {boolean} enabled True or false.
     * @param {boolean} debug True or false.
     */
    setLogging(enabled: boolean, debug: boolean): void;
    setMaterialNames(materialNames: Set<string>): void;
    isLoggingEnabled(): boolean;
    isDebugLoggingEnabled(): boolean;
    /**
     *
     * @returns if parser was used before
     */
    isUsedBefore(): boolean;
    private configure;
    /**
     * Parse the provided arraybuffer
     *
     * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array
     */
    execute(arrayBuffer: ArrayBufferLike): void;
    /**
     * Parse the provided text
     *
     * @param {string} text OBJ data as string
     */
    executeLegacy(text: string): void;
    private processLine;
    private pushSmoothingGroup;
    /**
     * Expanded faceTypes include all four face types, both line types and the point type
     * faceType = 0: "f vertex ..."
     * faceType = 1: "f vertex/uv ..."
     * faceType = 2: "f vertex/uv/normal ..."
     * faceType = 3: "f vertex//normal ..."
     * faceType = 4: "l vertex/uv ..." or "l vertex ..."
     * faceType = 5: "l vertex ..."
     * faceType = 6: "p vertex ..."
     */
    private checkFaceType;
    private checkSubGroup;
    private buildFace;
    private createRawMeshReport;
    /**
     * Clear any empty subGroup and calculate absolute vertex, normal and uv counts
     */
    private finalizeRawMesh;
    private processCompletedMesh;
    private resetRawMesh;
    /**
     * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.
     * It is ensured that SubGroups only contain objects with vertices (no need to check).
     *
     * @param result
     */
    private createPreparedMesh;
    private finalizeParsing;
    /**
     * Announce parse progress feedback which is logged to the console.
     * @private
     *
     * @param {string} text Textual description of the event
     */
    _onProgress(text: string): void;
    /**
     * Announce error feedback which is logged as error message.
     * @private
     *
     * @param {String} errorMessage The event containing the error
     */
    _onError(errorMessage: string): void;
    /**
     * Hook for alteration or transfer to main when parser is run in worker
     *
     * @param {Mesh} _mesh
     * @param {object} _materialMetaInfo
     */
    _onAssetAvailable(_mesh: PreparedMeshType, _materialMetaInfo?: unknown): void;
    _onLoad(): void;
}
//# sourceMappingURL=OBJLoader2Parser.d.ts.map