import { Loader, LineSegments, Points, Object3D, Mesh, Material, LoadingManager } from 'three';
import { AssociatedMaterialArrayType, MaterialStore } from 'wtd-three-ext';
import { MaterialMetaInfoType, OBJLoader2Parser, PreparedMeshType } from './OBJLoader2Parser.js';
export type CallbackOnLoadType = ((data: Object3D) => void);
export type CallbackOnProgressMessageType = ((progressMessage: string) => void);
export type CallbackOnErrorMessageType = ((error: Error) => void);
export type CallbackOnMeshAlterType = ((mesh: Mesh | LineSegments | Points, data: Object3D) => void);
export type CallbacksType = {
    onLoad?: CallbackOnLoadType;
    onError?: CallbackOnErrorMessageType;
    onProgress?: CallbackOnProgressMessageType;
    onMeshAlter?: CallbackOnMeshAlterType;
};
export type FileLoaderOnLoadType = (response: string | ArrayBuffer) => void;
export type FileLoaderOnProgressType = (request: ProgressEvent) => void;
export type FileLoaderOnErrorType = (event: ErrorEvent | unknown) => void;
/**
 * Creates a new OBJLoader2. Use it to load OBJ data from files or to parse OBJ data from arraybuffer or text.
 *
 * @param {LoadingManager} [manager] The loadingManager for the loader to use. Default is {@link LoadingManager}
 * @constructor
 */
export declare class OBJLoader2 extends Loader<Object3D, string> {
    static OBJLOADER2_VERSION: string;
    protected parser: OBJLoader2Parser;
    protected baseObject3d: Object3D<import("three").Object3DEventMap>;
    protected materialStore: MaterialStore;
    protected materialPerSmoothingGroup: boolean;
    protected useOAsMesh: boolean;
    protected useIndices: boolean;
    protected disregardNormals: boolean;
    protected modelName: string;
    private callbacks;
    /**
     *
     * @param {LoadingManager} [manager]
     */
    constructor(manager?: LoadingManager);
    /**
     * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
     *
     * @param {boolean} enabled True or false.
     * @param {boolean} debug True or false.
     *
     * @return {OBJLoader2}
     */
    setLogging(enabled: boolean, debug: boolean): this;
    /**
     * Tells whether a material shall be created per smoothing group.
     *
     * @param {boolean} materialPerSmoothingGroup=false
     * @return {OBJLoader2}
     */
    setMaterialPerSmoothingGroup(materialPerSmoothingGroup: boolean): this;
    /**
     * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of "o" can be enforced.
     *
     * @param {boolean} useOAsMesh=false
     * @return {OBJLoader2}
     */
    setUseOAsMesh(useOAsMesh: boolean): this;
    /**
     * Instructs loaders to create indexed {@link BufferGeometry}.
     *
     * @param {boolean} useIndices=false
     * @return {OBJLoader2}
     */
    setUseIndices(useIndices: boolean): this;
    /**
     * Tells whether normals should be completely disregarded and regenerated.
     *
     * @param {boolean} disregardNormals=false
     * @return {OBJLoader2}
     */
    setDisregardNormals(disregardNormals: boolean): this;
    /**
     * Set the name of the model.
     *
     * @param {string} modelName
     * @return {OBJLoader2}
     */
    setModelName(modelName: string): this;
    /**
     * Returns the name of the models
     * @return {String}
     */
    getModelName(): string;
    /**
     * Set the node where the loaded objects will be attached directly.
     *
     * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to
     * @return {OBJLoader2}
     */
    setBaseObject3d(baseObject3d: Object3D): this;
    /**
     * Clears materials object and sets the new ones.
     *
     * @param {Object} materials Object with named materials
     * @return {OBJLoader2}
     */
    setMaterials(materials: AssociatedMaterialArrayType): this;
    /**
     * Register a function that is called when parsing was completed.
     *
     * @param {CallbackOnLoadType} onLoad
     * @return {OBJLoader2}
     */
    setCallbackOnLoad(onLoad: CallbackOnLoadType): this;
    /**
     * Register a function that is used to report overall processing progress.
     *
     * @param {CallbackOnProgressMessageType} onProgress
     * @return {OBJLoader2}
     */
    setCallbackOnProgress(onProgress: CallbackOnProgressMessageType): this;
    /**
     * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.
     *
     * @param {CallbackOnErrorMessageType} onError
     * @return {OBJLoader2}
     */
    setCallbackOnError(onError: CallbackOnErrorMessageType): this;
    /**
     * Register a function that is called once a single mesh is available and it could be altered by the supplied function.
     *
     * @param {CallbackOnMeshAlterType} onMeshAlter
     * @return {OBJLoader2}
     */
    setCallbackOnMeshAlter(onMeshAlter: CallbackOnMeshAlterType): this;
    /**
     * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.
     *
     * @param {string}  url A string containing the path/URL of the file to be loaded.
     * @param {FileLoaderOnLoadType} [onLoad] A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.
     * @param {FileLoaderOnProgressType} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.
     * @param {FileLoaderOnErrorType} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.
     * @param {OnMeshAlterType} [onMeshAlter] Called after every single mesh is made available by the parser
     */
    load(url: string | undefined, onLoad: CallbackOnLoadType, onProgress?: FileLoaderOnProgressType, onError?: FileLoaderOnErrorType, onMeshAlter?: CallbackOnMeshAlterType): void;
    /**
     * Overrides the implementation of THREE.Loader, so it supports onMeshAlter.
     *
     * @param {string}  url A string containing the path/URL of the file to be loaded.
     * @param {FileLoaderOnProgressType} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.
     * @param {CallbackOnMeshAlterType} [onMeshAlter] Called after every single mesh is made available by the parser url
     * @returns Promise
     */
    loadAsync(url: string, onProgress?: FileLoaderOnProgressType, onMeshAlter?: CallbackOnMeshAlterType): Promise<Object3D>;
    /**
     * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.
     *
     * @param {ArrayBuffer|string} content OBJ data as Uint8Array or String
     * @return {Object3D}
     */
    parse(objToParse: string | ArrayBuffer): Object3D<import("three").Object3DEventMap>;
    private configure;
    protected printCallbackConfig(): void;
    static buildThreeMesh({ meshName: meshName, vertexFA: vertexFA, normalFA: normalFA, uvFA: uvFA, colorFA: colorFA, indexUA: indexUA, createMultiMaterial: createMultiMaterial, geometryGroups: geometryGroups, multiMaterial: multiMaterial, materialMetaInfo: materialMetaInfo }: PreparedMeshType, materials: Map<string, Material>, debugLogging: boolean): Mesh | LineSegments | Points;
    _onProgress(text: string): void;
    _onError(error: Error): void;
    _onMeshAlter(mesh: Mesh | LineSegments | Points, _materialMetaInfo?: MaterialMetaInfoType): void;
    _onLoad(): void;
}
//# sourceMappingURL=OBJLoader2.d.ts.map