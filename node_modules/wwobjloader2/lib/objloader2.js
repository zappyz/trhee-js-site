var se = Object.defineProperty;
var re = (o, e, t) => e in o ? se(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var n = (o, e, t) => (re(o, typeof e != "symbol" ? e + "" : e, t), t);
import { Color as ie, MeshStandardMaterial as J, LineBasicMaterial as ae, PointsMaterial as oe, MaterialLoader as ne, Texture as le, BufferGeometry as S, BufferAttribute as v, Box3 as ce, Sphere as he, Loader as ue, Object3D as K, FileLoader as Y, Mesh as de, LineSegments as ge, Points as me } from "three";
class pe {
  constructor() {
    n(this, "logging");
    n(this, "usedBefore", !1);
    n(this, "contentRef", "");
    n(this, "legacyMode", !1);
    n(this, "materialNames", /* @__PURE__ */ new Set());
    n(this, "modelName", "noname");
    n(this, "materialPerSmoothingGroup", !1);
    n(this, "useOAsMesh", !1);
    n(this, "useIndices", !1);
    n(this, "disregardNormals", !1);
    n(this, "vertices", []);
    n(this, "colors", []);
    n(this, "normals", []);
    n(this, "uvs", []);
    n(this, "rawMesh");
    n(this, "inputObjectCount", 1);
    n(this, "outputObjectCount", 1);
    n(this, "globalCounts");
    this.logging = this.buildDefaultLogging(), this.rawMesh = this.buildDefaultRawMesh(), this.globalCounts = this.buildDefaultGlobalsCount();
  }
  buildDefaultLogging() {
    return {
      enabled: !1,
      debug: !1
    };
  }
  buildDefaultRawMesh() {
    return {
      objectName: "",
      groupName: "",
      activeMtlName: "",
      mtllibName: "",
      // reset with new mesh
      faceType: -1,
      subGroups: /* @__PURE__ */ new Map(),
      subGroupInUse: void 0,
      smoothingGroup: {
        splitMaterials: !1,
        normalized: -1,
        real: -1
      },
      counts: {
        doubleIndicesCount: 0,
        faceCount: 0,
        mtlCount: 0,
        smoothingGroupCount: 0
      }
    };
  }
  buildDefaultGlobalsCount() {
    return {
      vertices: 0,
      faces: 0,
      doubleIndicesCount: 0,
      lineByte: 0,
      currentByte: 0,
      totalBytes: 0
    };
  }
  setBulkConfig(e) {
    this.materialPerSmoothingGroup = e.materialPerSmoothingGroup, this.useOAsMesh = e.useOAsMesh, this.useIndices = e.useIndices, this.disregardNormals = e.disregardNormals, this.modelName = e.modelName, this.materialNames = e.materialNames;
  }
  /**
   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
   *
   * @param {boolean} enabled True or false.
   * @param {boolean} debug True or false.
   */
  setLogging(e, t) {
    this.logging.enabled = e === !0, this.logging.debug = t === !0;
  }
  setMaterialNames(e) {
    this.materialNames = e;
  }
  isLoggingEnabled() {
    return this.logging.enabled;
  }
  isDebugLoggingEnabled() {
    return this.logging.enabled && this.logging.debug;
  }
  /**
   *
   * @returns if parser was used before
   */
  isUsedBefore() {
    return this.usedBefore;
  }
  configure() {
    if (this.usedBefore = !0, this.pushSmoothingGroup("1"), this.logging.enabled) {
      const t = "OBJLoader2 Parser configuration:" + (this.materialNames.size > 0 ? `
	materialNames:
		- ` + Array.from(this.materialNames).join(`
		- `) : `
	materialNames: None`) + `
	materialPerSmoothingGroup: ` + this.materialPerSmoothingGroup + `
	useOAsMesh: ` + this.useOAsMesh + `
	useIndices: ` + this.useIndices + `
	disregardNormals: ` + this.disregardNormals;
      console.info(t);
    }
  }
  /**
   * Parse the provided arraybuffer
   *
   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array
   */
  execute(e) {
    this.logging.enabled && console.time("OBJLoader2Parser.execute"), this.configure();
    const t = new Uint8Array(e);
    this.contentRef = t;
    const s = t.byteLength;
    this.globalCounts.totalBytes = s;
    const r = new Array(128);
    let i = 0, a = 0, c = "", l = 0;
    for (let h; l < s; l++)
      switch (h = t[l], h) {
        case 32:
          c.length > 0 && (r[i++] = c), c = "";
          break;
        case 47:
          c.length > 0 && (r[i++] = c), a++, c = "";
          break;
        case 10:
          this.processLine(r, i, a, c, l), c = "", i = 0, a = 0;
          break;
        case 13:
          break;
        default:
          c += String.fromCharCode(h);
          break;
      }
    this.processLine(r, i, a, c, l), this.finalizeParsing(), this.logging.enabled && console.timeEnd("OBJLoader2Parser.execute");
  }
  /**
   * Parse the provided text
   *
   * @param {string} text OBJ data as string
   */
  executeLegacy(e) {
    this.logging.enabled && console.time("OBJLoader2Parser.executeLegacy"), this.configure(), this.legacyMode = !0, this.contentRef = e;
    const t = e.length;
    this.globalCounts.totalBytes = t;
    const s = new Array(128);
    let r = 0, i = 0, a = "", c = 0;
    for (let l; c < t; c++)
      switch (l = e[c], l) {
        case " ":
          a.length > 0 && (s[r++] = a), a = "";
          break;
        case "/":
          a.length > 0 && (s[r++] = a), i++, a = "";
          break;
        case `
`:
          this.processLine(s, r, i, a, c), a = "", r = 0, i = 0;
          break;
        case "\r":
          break;
        default:
          a += l;
      }
    this.processLine(s, r, i, a, c), this.finalizeParsing(), this.logging.enabled && console.timeEnd("OBJLoader2Parser.executeLegacy");
  }
  processLine(e, t, s, r, i) {
    if (this.globalCounts.lineByte = this.globalCounts.currentByte, this.globalCounts.currentByte = i, t < 1)
      return;
    r.length > 0 && (e[t++] = r);
    const a = (d, u, p, m) => {
      let b = "";
      if (m > p) {
        let f;
        if (u)
          for (f = p; f < m; f++)
            b += d[f];
        else
          for (f = p; f < m; f++)
            b += String.fromCharCode(d[f]);
        b = b.trim();
      }
      return b;
    };
    let c, l, h;
    const g = e[0];
    switch (g) {
      case "v":
        if (this.vertices.push(parseFloat(e[1])), this.vertices.push(parseFloat(e[2])), this.vertices.push(parseFloat(e[3])), t > 4) {
          const u = new ie();
          u.setRGB(
            parseFloat(e[4]),
            parseFloat(e[5]),
            parseFloat(e[6])
          ).convertSRGBToLinear(), this.colors.push(u.r), this.colors.push(u.g), this.colors.push(u.b);
        }
        break;
      case "vt":
        this.uvs.push(parseFloat(e[1])), this.uvs.push(parseFloat(e[2]));
        break;
      case "vn":
        this.normals.push(parseFloat(e[1])), this.normals.push(parseFloat(e[2])), this.normals.push(parseFloat(e[3]));
        break;
      case "f":
        if (c = t - 1, s === 0)
          for (this.checkFaceType(0), h = 2, l = c; h < l; h++)
            this.buildFace(e[1]), this.buildFace(e[h]), this.buildFace(e[h + 1]);
        else if (c === s * 2)
          for (this.checkFaceType(1), h = 3, l = c - 2; h < l; h += 2)
            this.buildFace(e[1], e[2]), this.buildFace(e[h], e[h + 1]), this.buildFace(e[h + 2], e[h + 3]);
        else if (c * 2 === s * 3)
          for (this.checkFaceType(2), h = 4, l = c - 3; h < l; h += 3)
            this.buildFace(e[1], e[2], e[3]), this.buildFace(e[h], e[h + 1], e[h + 2]), this.buildFace(e[h + 3], e[h + 4], e[h + 5]);
        else
          for (this.checkFaceType(3), h = 3, l = c - 2; h < l; h += 2)
            this.buildFace(e[1], void 0, e[2]), this.buildFace(e[h], void 0, e[h + 1]), this.buildFace(e[h + 2], void 0, e[h + 3]);
        break;
      case "l":
      case "p":
        if (c = t - 1, c === s * 2)
          for (this.checkFaceType(4), h = 1, l = c + 1; h < l; h += 2)
            this.buildFace(e[h], e[h + 1]);
        else
          for (this.checkFaceType(g === "l" ? 5 : 6), h = 1, l = c + 1; h < l; h++)
            this.buildFace(e[h]);
        break;
      case "s":
        this.pushSmoothingGroup(e[1]);
        break;
      case "g":
        this.processCompletedMesh(), this.rawMesh.groupName = a(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);
        break;
      case "o":
        this.useOAsMesh && this.processCompletedMesh(), this.rawMesh.objectName = a(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);
        break;
      case "mtllib":
        this.rawMesh.mtllibName = a(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);
        break;
      case "usemtl":
        const d = a(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);
        d !== "" && this.rawMesh.activeMtlName !== d && (this.rawMesh.activeMtlName = d, this.rawMesh.counts.mtlCount++, this.checkSubGroup());
        break;
    }
  }
  pushSmoothingGroup(e) {
    let t = parseInt(e);
    isNaN(t) && (t = e === "off" ? 0 : 1);
    const s = this.rawMesh.smoothingGroup.normalized;
    this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? t : t === 0 ? 0 : 1, this.rawMesh.smoothingGroup.real = t, s !== t && (this.rawMesh.counts.smoothingGroupCount++, this.checkSubGroup());
  }
  /**
   * Expanded faceTypes include all four face types, both line types and the point type
   * faceType = 0: "f vertex ..."
   * faceType = 1: "f vertex/uv ..."
   * faceType = 2: "f vertex/uv/normal ..."
   * faceType = 3: "f vertex//normal ..."
   * faceType = 4: "l vertex/uv ..." or "l vertex ..."
   * faceType = 5: "l vertex ..."
   * faceType = 6: "p vertex ..."
   */
  checkFaceType(e) {
    this.rawMesh.faceType !== e && (this.processCompletedMesh(), this.rawMesh.faceType = e, this.checkSubGroup());
  }
  checkSubGroup() {
    const e = `${this.rawMesh.activeMtlName}|${this.rawMesh.smoothingGroup.normalized}`;
    this.rawMesh.subGroupInUse = this.rawMesh.subGroups.get(e), this.rawMesh.subGroupInUse || (this.rawMesh.subGroupInUse = {
      index: e,
      objectName: this.rawMesh.objectName,
      groupName: this.rawMesh.groupName,
      materialName: this.rawMesh.activeMtlName,
      smoothingGroup: this.rawMesh.smoothingGroup.normalized,
      vertices: [],
      indexMappingsCount: 0,
      indexMappings: /* @__PURE__ */ new Map(),
      indices: [],
      colors: [],
      uvs: [],
      normals: []
    }, this.rawMesh.subGroups.set(e, this.rawMesh.subGroupInUse));
  }
  buildFace(e, t, s) {
    const r = this.rawMesh.subGroupInUse, i = () => {
      const a = parseInt(e);
      let c = 3 * (a > 0 ? a - 1 : a + this.vertices.length / 3), l = this.colors.length > 0 ? c : null;
      const h = r.vertices;
      if (h.push(this.vertices[c++]), h.push(this.vertices[c++]), h.push(this.vertices[c]), l !== null) {
        const g = r.colors;
        g.push(this.colors[l++]), g.push(this.colors[l++]), g.push(this.colors[l]);
      }
      if (t) {
        const g = parseInt(t);
        let d = 2 * (g > 0 ? g - 1 : g + this.uvs.length / 2);
        const u = r.uvs;
        u.push(this.uvs[d++]), u.push(this.uvs[d]);
      }
      if (s && !this.disregardNormals) {
        const g = parseInt(s);
        let d = 3 * (g > 0 ? g - 1 : g + this.normals.length / 3);
        const u = r.normals;
        u.push(this.normals[d++]), u.push(this.normals[d++]), u.push(this.normals[d]);
      }
    };
    if (this.useIndices) {
      this.disregardNormals && (s = void 0);
      const a = e + (t ? "_" + t : "_n") + (s ? "_" + s : "_n");
      let c = r.indexMappings.get(a);
      c == null ? (c = this.rawMesh.subGroupInUse.vertices.length / 3, i(), r.indexMappings.set(a, c), r.indexMappingsCount++) : this.rawMesh.counts.doubleIndicesCount++, r.indices.push(c);
    } else
      i();
    this.rawMesh.counts.faceCount++;
  }
  createRawMeshReport(e) {
    return `Input Object number: ${e}
	Object name: ${this.rawMesh.objectName}
	Group name: ${this.rawMesh.groupName}
	Mtllib name: ${this.rawMesh.mtllibName}
	Vertex count: ${this.vertices.length / 3}
	Normal count: ${this.normals.length / 3}
	UV count: ${this.uvs.length / 2}
	SmoothingGroup count: ${this.rawMesh.counts.smoothingGroupCount}
	Material count: ${this.rawMesh.counts.mtlCount}
	Real MeshOutputGroup count: ${this.rawMesh.subGroups.size}`;
  }
  /**
   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts
   */
  finalizeRawMesh() {
    const e = [];
    let t, s = 0, r = 0, i = 0, a = 0, c = 0, l = 0, h;
    for (const g of this.rawMesh.subGroups.entries())
      if (t = this.rawMesh.subGroups.get(g[0]), t && t.vertices.length > 0) {
        if (h = t.indices, h.length > 0 && r > 0)
          for (let d = 0; d < h.length; d++)
            h[d] = h[d] + r;
        e.push(t), s += t.vertices.length, r += t.indexMappingsCount, i += t.indices.length, a += t.colors.length, l += t.uvs.length, c += t.normals.length;
      }
    if (e.length > 0)
      return {
        name: this.rawMesh.groupName !== "" ? this.rawMesh.groupName : this.rawMesh.objectName,
        subGroups: e,
        absoluteVertexCount: s,
        absoluteIndexCount: i,
        absoluteColorCount: a,
        absoluteNormalCount: c,
        absoluteUvCount: l,
        faceCount: this.rawMesh.counts.faceCount,
        doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount
      };
  }
  processCompletedMesh() {
    const e = this.finalizeRawMesh();
    if (e) {
      this.colors.length > 0 && this.colors.length !== this.vertices.length && this._onError("Vertex Colors were detected, but vertex count and color count do not match!"), this.logging.enabled && this.logging.debug && console.debug(this.createRawMeshReport(this.inputObjectCount)), this.inputObjectCount++;
      const t = this.createPreparedMesh(e);
      this._onAssetAvailable(t);
      const s = this.globalCounts.currentByte / this.globalCounts.totalBytes;
      return this._onProgress("Completed [o: " + this.rawMesh.objectName + " g:" + this.rawMesh.groupName + "] Total progress: " + (s * 100).toFixed(2) + "%"), this.resetRawMesh(), !0;
    }
    return !1;
  }
  resetRawMesh() {
    this.rawMesh.subGroups = /* @__PURE__ */ new Map(), this.rawMesh.subGroupInUse = void 0, this.rawMesh.smoothingGroup.normalized = -1, this.rawMesh.smoothingGroup.real = -1, this.pushSmoothingGroup("1"), this.rawMesh.counts.doubleIndicesCount = 0, this.rawMesh.counts.faceCount = 0, this.rawMesh.counts.mtlCount = 0, this.rawMesh.counts.smoothingGroupCount = 0;
  }
  /**
   * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.
   * It is ensured that SubGroups only contain objects with vertices (no need to check).
   *
   * @param result
   */
  createPreparedMesh(e) {
    const t = e.subGroups;
    if (this.globalCounts.vertices += e.absoluteVertexCount / 3, this.globalCounts.faces += e.faceCount, this.globalCounts.doubleIndicesCount += e.doubleIndicesCount, e.absoluteVertexCount <= 0)
      throw new Error(`Invalid vertex count: ${e.absoluteVertexCount}`);
    const s = new Float32Array(e.absoluteVertexCount), r = e.absoluteIndexCount > 0 ? new Uint32Array(e.absoluteIndexCount) : null, i = e.absoluteColorCount > 0 ? new Float32Array(e.absoluteColorCount) : null, a = e.absoluteNormalCount > 0 ? new Float32Array(e.absoluteNormalCount) : null, c = e.absoluteUvCount > 0 ? new Float32Array(e.absoluteUvCount) : null;
    let l, h = 0, g = 0, d = 0, u = 0, p = 0;
    const m = [];
    let b = 0, f = 0;
    const E = t.length > 1, L = [], w = i !== null;
    let y = 0;
    const x = {
      materialCloneInstructions: [],
      materialName: "",
      multiMaterialNames: /* @__PURE__ */ new Map(),
      modelName: this.modelName,
      geometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1
    };
    for (const j in t) {
      if (!Object.prototype.hasOwnProperty.call(t, j))
        continue;
      l = t[j];
      let k;
      const D = l.materialName, W = l.smoothingGroup === 0;
      this.rawMesh.faceType < 4 ? (k = D, w && (k += "_vertexColor"), W && (k += "_flat")) : k = this.rawMesh.faceType === 6 ? "defaultPointMaterial" : "defaultLineMaterial", x.materialName = k;
      const q = this.materialNames.has(D), $ = this.materialNames.has(k), V = !q && !$, ee = V ? !1 : !$;
      if (V && (k = w ? "defaultVertexColorMaterial" : "defaultMaterial", this.logging.enabled && console.info('object_group "' + l.objectName + "_" + l.groupName + '" was defined with unresolvable material "' + D + '"! Assigning "' + k + '".'), x.materialName = k), ee) {
        const F = {
          materialNameOrg: D,
          materialProperties: {
            name: k,
            vertexColors: w ? 2 : 0,
            flatShading: W
          }
        };
        x.materialCloneInstructions.push(F);
      }
      if (E && (f = this.useIndices ? l.indices.length : l.vertices.length / 3, m.push({
        materialGroupOffset: b,
        materialGroupLength: f,
        materialIndex: y
      }), L[y] = k, x.multiMaterialNames.set(y, k), b += f, y++), s !== null && (s.set(l.vertices, h), h += l.vertices.length), r !== null && (r.set(l.indices, g), g += l.indices.length), i !== null && (i.set(l.colors, d), d += l.colors.length), a !== null && (a.set(l.normals, u), u += l.normals.length), c !== null && (c.set(l.uvs, p), p += l.uvs.length), this.logging.enabled && this.logging.debug) {
        let F = "";
        y > 0 && (F = `
		materialIndex: ` + y);
        const te = "	Output Object no.: " + this.outputObjectCount + `
		groupName: ` + l.groupName + `
		Index: ` + l.index + `
		faceType: ` + this.rawMesh.faceType + `
		materialName: ` + l.materialName + `
		smoothingGroup: ` + l.smoothingGroup + F + `
		objectName: ` + l.objectName + `
		#vertices: ` + l.vertices.length / 3 + `
		#indices: ` + l.indices.length + `
		#colors: ` + l.colors.length / 3 + `
		#uvs: ` + l.uvs.length / 2 + `
		#normals: ` + l.normals.length / 3;
        console.debug(te);
      }
    }
    return this.outputObjectCount++, {
      meshName: e.name,
      vertexFA: s,
      normalFA: a,
      uvFA: c,
      colorFA: i,
      indexUA: r,
      createMultiMaterial: E,
      geometryGroups: m,
      multiMaterial: L,
      materialMetaInfo: x,
      progress: this.globalCounts.currentByte / this.globalCounts.totalBytes
    };
  }
  finalizeParsing() {
    if (this.logging.enabled && console.info("Global output object count: " + this.outputObjectCount), this.processCompletedMesh() && this.logging.enabled) {
      const e = `Overall counts: 
	Vertices: ` + this.globalCounts.vertices + `
	Faces: ` + this.globalCounts.faces + `
	Multiple definitions: ` + this.globalCounts.doubleIndicesCount;
      console.info(e);
    }
    this._onLoad();
  }
  /**
   * Announce parse progress feedback which is logged to the console.
   * @private
   *
   * @param {string} text Textual description of the event
   */
  _onProgress(e) {
    const t = e || "";
    this.logging.enabled && this.logging.debug && console.log(t);
  }
  /**
   * Announce error feedback which is logged as error message.
   * @private
   *
   * @param {String} errorMessage The event containing the error
   */
  _onError(e) {
    this.logging.enabled && this.logging.debug && console.error(e);
  }
  /**
   * Hook for alteration or transfer to main when parser is run in worker
   *
   * @param {Mesh} _mesh
   * @param {object} _materialMetaInfo
   */
  _onAssetAvailable(e, t) {
  }
  _onLoad() {
  }
}
class O {
  /**
   * Adds the provided material to the provided map of materials if the material does not exists.
   * Use force override existing material.
   *
   * @param {Map<string, Material>} materialsObject
   * @param {string} materialName
   * @param {Material} material
   * @param {boolean} force Enforce addition of provided material
   * @param {boolean} [log] Log messages to the console
   */
  static addMaterial(e, t, s, r, i) {
    let a;
    s.name = t, r ? (e.set(t, s), i && console.info('Material with name "' + t + '" was forcefully overridden.')) : (a = e.get(t), a ? a.uuid !== a.uuid && i && console.log('Same material name "' + a.name + '" different uuid [' + a.uuid + "|" + s.uuid + "]") : (e.set(t, s), i && console.info('Material with name "' + t + '" was added.')));
  }
  /**
   * Transforms the named materials object to an object with named jsonified materials.
   *
   * @param {Map<string, Material>}
   * @returns {Map<string, unknown>} Map of Materials in JSON representation
   */
  static getMaterialsJSON(e) {
    const t = /* @__PURE__ */ new Map();
    for (const s of e.entries())
      typeof s[1].toJSON == "function" && t.set(s[0], s[1].toJSON());
    return t;
  }
  /**
   * Clones a material according the provided instructions.
   *
   * @param {Map<string, Material>} materials
   * @param {MaterialCloneInstructionsType} materialCloneInstruction
   * @param {boolean} [log]
   */
  static cloneMaterial(e, t, s) {
    if (t) {
      let r = t.materialNameOrg;
      r = r ?? "";
      const i = e.get(r);
      if (i) {
        const a = i.clone();
        return Object.assign(a, t.materialProperties), O.addMaterial(e, t.materialProperties.name, a, !0, s), a;
      } else
        s && console.info('Requested material "' + r + '" is not available!');
    }
  }
}
class fe {
  /**
   * Creates a new {@link MaterialStore}.
   * @param {boolean} createDefaultMaterials
   */
  constructor(e) {
    n(this, "materials");
    if (this.materials = /* @__PURE__ */ new Map(), e) {
      const t = new J({ color: 14479871 });
      t.name = "defaultMaterial";
      const s = new J({ color: 14479871 });
      s.name = "defaultVertexColorMaterial", s.vertexColors = !0;
      const r = new ae();
      r.name = "defaultLineMaterial";
      const i = new oe({ size: 0.1 });
      i.name = "defaultPointMaterial", this.materials.set(t.name, t), this.materials.set(s.name, s), this.materials.set(r.name, r), this.materials.set(i.name, i);
    }
  }
  /**
   * Set materials loaded by any supplier of an Array of {@link Material}.
   *
   * @param {Map<string, Material>} newMaterials Object with named {@link Material}
   * @param {boolean} forceOverrideExisting boolean Override existing material
   */
  addMaterials(e, t) {
    if (e && e !== null && e.size > 0)
      for (const s of e.entries())
        O.addMaterial(this.materials, s[0], s[1], t === !0);
  }
  addMaterialsFromObject(e, t) {
    if (e && e !== null && Object.keys(e).length > 0)
      for (const [s, r] of Object.entries(e))
        O.addMaterial(this.materials, s, r, t === !0);
  }
  getMaterials() {
    return this.materials;
  }
  getMaterial(e) {
    return this.materials.get(e);
  }
  clearMaterials() {
    this.materials.clear();
  }
}
var _;
(function(o) {
  o.INIT = "init", o.INIT_CHANNEL = "initChannel", o.INTERMEDIATE = "intermediate", o.EXECUTE = "execute", o.INTERCOM_INIT = "interComInit", o.INTERCOM_INTERMEDIATE = "interComIntermediate", o.INTERCOM_EXECUTE = "interComExecute";
})(_ || (_ = {}));
var A;
(function(o) {
  o.INIT_COMPLETE = "initComplete", o.INIT_CHANNEL_COMPLETE = "initChannelComplete", o.INTERMEDIATE_CONFIRM = "intermediateConfirm", o.EXECUTE_COMPLETE = "executeComplete", o.INTERCOM_INIT_COMPLETE = "interComInitComplete", o.INTERCOM_INTERMEDIATE_CONFIRM = "interComIntermediateConfirm", o.INTERCOM_EXECUTE_COMPLETE = "interComExecuteComplete";
})(A || (A = {}));
var z;
(function(o) {
  o.INIT_OFFSCREEN_CANVAS = "initOffscreenCanvas", o.PROXY_START = "proxyStart", o.PROXY_EVENT = "proxyEvent", o.RESIZE = "resize";
})(z || (z = {}));
var H;
(function(o) {
  o.INIT_OFFSCREEN_CANVAS_COMPLETE = "initOffscreenCanvasComplete", o.PROXY_START_COMPLETE = "proxyStartComplete", o.PROXY_EVENT_COMPLETE = "proxyEventComplete", o.RESIZE_COMPLETE = "resizeComplete";
})(H || (H = {}));
class T {
}
n(T, "handler", /* @__PURE__ */ new Map());
class C {
  constructor(e) {
    n(this, "cmd", "unknown");
    n(this, "uuid", "unknown");
    n(this, "name", "unnamed");
    n(this, "workerId", 0);
    n(this, "progress", 0);
    n(this, "payloads", []);
    this.cmd = (e == null ? void 0 : e.cmd) ?? this.cmd, this.name = (e == null ? void 0 : e.name) ?? this.name, this.workerId = (e == null ? void 0 : e.workerId) ?? this.workerId, this.progress = (e == null ? void 0 : e.progress) ?? this.progress;
  }
  addPayload(e) {
    e && (Array.isArray(e) ? this.payloads = this.payloads.concat(e) : this.payloads.push(e));
  }
  static createNew(e) {
    return new C(e);
  }
  static createEmpty() {
    return C.createNew({});
  }
  static createFromExisting(e, t) {
    const s = C.createNew(e);
    return s.uuid = e.uuid, t != null && t.overrideCmd && (s.cmd = t.overrideCmd), t != null && t.overrideUuid && (s.uuid = t.overrideUuid), s;
  }
  static pack(e, t) {
    const s = [];
    if (e)
      for (const r of e) {
        const i = T.handler.get(r.$type);
        i == null || i.pack(r, s, t === !0);
      }
    return s;
  }
  static unpack(e, t) {
    const s = C.createFromExisting(e, {
      overrideUuid: e.uuid
    });
    if (e.payloads)
      for (const r of e.payloads) {
        const i = T.handler.get(r.$type);
        s.addPayload(i == null ? void 0 : i.unpack(r, t === !0));
      }
    return s;
  }
  static fromPayload(e, t) {
    const s = C.createNew({
      cmd: t
    });
    return s.addPayload(e), s;
  }
}
class be {
  constructor(e) {
    n(this, "taskName");
    n(this, "workerId");
    n(this, "workerConfig");
    n(this, "verbose", !1);
    n(this, "worker");
    n(this, "executing", !1);
    n(this, "executionCounter", 0);
    n(this, "awaitAnswers", /* @__PURE__ */ new Map());
    this.taskName = e.taskName, this.workerId = e.workerId, this.workerConfig = e.workerConfig, this.verbose = e.verbose === !0;
  }
  isWorkerExecuting() {
    return this.executing;
  }
  markExecuting(e) {
    this.executing = e;
  }
  getWorker() {
    return this.worker;
  }
  connectWorker() {
    if (this.worker)
      throw new Error("Worker already created. Aborting...");
    if (this.workerConfig.$type === "WorkerConfigDirect" ? this.worker = this.workerConfig.worker : this.workerConfig.$type === "WorkerConfigParams" && this.workerConfig.url && (this.workerConfig.blob ? this.worker = new Worker(this.workerConfig.url) : this.worker = new Worker(this.workerConfig.url.href, {
      type: this.workerConfig.workerType
    })), !this.worker)
      throw new Error("No valid worker configuration was supplied. Aborting...");
    this.worker.onmessage = async (e) => {
      const t = e.data;
      if (t.cmd) {
        const s = this.awaitAnswers.get(t.uuid ?? "unknown");
        s == null || s.forEach((r) => {
          if (r.name === t.cmd) {
            if (r.log === !0) {
              const i = `Received: ${t.cmd} (workerName: ${t.name ?? "unknown"}) with uuid: ${t.uuid}`;
              console.log(i);
            }
            for (const i of r.resolve)
              i(t);
            r.endExecution === !0 && this.markExecuting(!1), r.remove === !0 && this.awaitAnswers.delete(t.uuid);
          }
        });
      } else
        console.error(`Received: unknown message: ${t}`);
    }, this.worker.onerror = async (e) => {
      console.log(`Execution Aborted: ${e.error}`), Promise.reject(e), this.markExecuting(!1);
    };
  }
  async initWorker(e) {
    return new Promise((t, s) => {
      var r;
      if (!this.worker)
        s(new Error("No worker is available. Aborting...")), this.markExecuting(!1);
      else {
        this.verbose && console.log(`Task: ${this.taskName}: Waiting for completion of worker init.`);
        const i = e.message;
        i.cmd = _.INIT;
        const a = this.handleTransferables(e);
        this.updateAwaitHandlers(i, [{
          name: A.INIT_COMPLETE,
          resolve: [t],
          reject: s,
          remove: !0,
          log: this.verbose
        }]), (r = this.worker) == null || r.postMessage(i, a);
      }
    });
  }
  async executeWorker(e) {
    return new Promise((t, s) => {
      if (!this.worker)
        s(new Error("No worker is available. Aborting...")), this.markExecuting(!1);
      else {
        this.markExecuting(!0);
        const r = e.message;
        r.cmd = _.EXECUTE;
        const i = this.handleTransferables(e), a = [], c = [];
        e.onComplete && c.push(e.onComplete), c.push(t), a.push({
          name: A.EXECUTE_COMPLETE,
          resolve: c,
          reject: s,
          remove: !0,
          endExecution: !0,
          log: this.verbose
        }), typeof e.onIntermediateConfirm == "function" && a.push({
          name: A.INTERMEDIATE_CONFIRM,
          resolve: [e.onIntermediateConfirm],
          reject: s,
          remove: !1,
          log: this.verbose
        }), this.updateAwaitHandlers(r, a), this.worker.postMessage(r, i);
      }
    });
  }
  /**
   * This is only possible if the worker is available.
   */
  sentMessage(e) {
    return new Promise((t, s) => {
      var r;
      if (this.checkWorker(s)) {
        const i = e.message;
        if (i.cmd === "unknown" || i.cmd.length === 0)
          throw new Error("No command provided. Aborting...");
        const a = this.handleTransferables(e);
        if (e.awaitAnswer === !0) {
          if (!e.answer) {
            s(new Error("No answer name provided. Aborting..."));
            return;
          }
          this.updateAwaitHandlers(i, [{
            name: e.answer,
            resolve: [t],
            reject: s,
            remove: !0,
            log: this.verbose
          }]);
        }
        (r = this.worker) == null || r.postMessage(i, a), e.awaitAnswer || t(C.createEmpty());
      }
    });
  }
  updateAwaitHandlers(e, t) {
    e.workerId = this.workerId, e.uuid = this.buildUuid(), this.awaitAnswers.set(e.uuid, t);
  }
  buildUuid() {
    return `${this.workerId}_${this.executionCounter++}_${Math.floor(Math.random() * 1e8)}`;
  }
  handleTransferables(e) {
    let t = [];
    if (e.transferables)
      if (e.copyTransferables === !0)
        for (const s of e.transferables)
          t.push(s.slice(0));
      else
        t = e.transferables;
    return t;
  }
  checkWorker(e) {
    return this.worker ? !0 : (e(new Error("No worker is available. Aborting...")), this.markExecuting(!1), !1);
  }
  dispose() {
    var e;
    (e = this.worker) == null || e.terminate();
  }
  printAwaitAnswers() {
    console.log(`${this.taskName}: awaitAnswers:`), console.log(this.awaitAnswers);
  }
}
const G = (o, e, t) => {
  for (const s of o) {
    const r = t ? s.slice(0) : s, i = r.buffer;
    i ? e.push(i) : e.push(r);
  }
}, we = (o, e, t) => {
  if (e)
    for (const [s, r] of Object.entries(e)) {
      const i = "set" + s.substring(0, 1).toLocaleUpperCase() + s.substring(1);
      Object.prototype.hasOwnProperty.call(o, i) && typeof o[i] == "function" ? o[i] = r : (Object.prototype.hasOwnProperty.call(o, s) || t) && (o[s] = r);
    }
};
class B {
  constructor() {
    n(this, "$type", "DataPayload");
    n(this, "message", {
      buffers: /* @__PURE__ */ new Map(),
      params: {}
    });
    n(this, "progress", 0);
  }
}
class Z {
  pack(e, t, s) {
    var i;
    const r = e;
    return r.message.buffers && G((i = r.message.buffers) == null ? void 0 : i.values(), t, s), t;
  }
  unpack(e, t) {
    const s = e, r = Object.assign(new B(), e);
    if (s.message.buffers)
      for (const [i, a] of s.message.buffers.entries())
        r.message.buffers && r.message.buffers.set(i, t ? a.slice(0) : a);
    return r;
  }
}
T.handler.set("DataPayload", new Z());
class Me {
  constructor() {
    n(this, "$type", "MaterialsPayload");
    n(this, "message", {
      buffers: /* @__PURE__ */ new Map(),
      params: {},
      materials: /* @__PURE__ */ new Map(),
      materialsJson: /* @__PURE__ */ new Map(),
      multiMaterialNames: /* @__PURE__ */ new Map(),
      cloneInstructions: []
    });
  }
  /**
   * Set an object containing named materials.
   * @param {Map<string, Material>} materials
   */
  setMaterials(e) {
    for (const [t, s] of e.entries())
      this.message.materials.set(t, s);
  }
  /**
  * Removes all textures and null values from all materials
  */
  cleanMaterials() {
    const e = /* @__PURE__ */ new Map();
    for (const t of this.message.materials.values())
      if (typeof t.clone == "function") {
        const s = t.clone();
        e.set(s.name, this.cleanMaterial(s));
      }
    this.message.materials = e;
  }
  cleanMaterial(e) {
    const t = e;
    for (const [s, r] of Object.entries(t))
      (r instanceof le || r === null) && Object.prototype.hasOwnProperty.call(e, s) && (t[s] = void 0);
    return e;
  }
  /**
    * Tell whether a multi-material was defined
    * @return {boolean}
    */
  hasMultiMaterial() {
    return this.message.multiMaterialNames.size > 0;
  }
  /**
   * Returns a single material if it is defined or null.
   * @return {Material|null}
   */
  getSingleMaterial() {
    return this.message.materials.size > 0 ? this.message.materials.values().next().value : void 0;
  }
  /**
   * Adds contained material or multi-material the provided materials object or it clones and adds new materials according clone instructions.
   *
   * @param {Map<string, Material>} materials
   * @param {boolean} log
   *
   * @return {Material|Material[]|undefined}
   */
  processMaterialTransport(e, t) {
    for (const s of this.message.cloneInstructions)
      O.cloneMaterial(e, s, t);
    if (this.hasMultiMaterial()) {
      const s = [];
      for (const [r, i] of this.message.multiMaterialNames.entries()) {
        const a = e.get(i);
        a && (s[r] = a);
      }
      return s;
    } else {
      const s = this.getSingleMaterial();
      if (s) {
        const r = e.get(s.name);
        return r || s;
      }
    }
  }
}
class ke {
  pack(e, t, s) {
    const r = e;
    return r.message.buffers && G(r.message.buffers.values(), t, s), r.message.materialsJson = O.getMaterialsJSON(r.message.materials), t;
  }
  unpack(e, t) {
    const s = e, r = Object.assign(new Me(), e);
    new Z().unpack(s, t);
    for (const [a, c] of s.message.multiMaterialNames.entries())
      r.message.multiMaterialNames.set(a, c);
    const i = new ne();
    for (const [a, c] of s.message.materialsJson.entries())
      r.message.materials.set(a, i.parse(c));
    return r;
  }
}
T.handler.set("MaterialsPayload", new ke());
var U;
(function(o) {
  o[o.MESH = 0] = "MESH", o[o.LINE = 1] = "LINE", o[o.POINT = 2] = "POINT";
})(U || (U = {}));
class Ce {
  constructor() {
    n(this, "$type", "MeshPayload");
    n(this, "message", {
      params: {},
      buffers: /* @__PURE__ */ new Map(),
      geometryType: U.MESH,
      bufferGeometry: new S(),
      meshName: ""
    });
  }
  /**
   * Set the {@link BufferGeometry} and geometry type that can be used when a mesh is created.
   *
   * @param {BufferGeometry} bufferGeometry
   * @param {number} geometryType [0=Mesh|1=LineSegments|2=Points]
   */
  setBufferGeometry(e, t) {
    this.message.bufferGeometry = e, this.message.geometryType = t;
  }
  /**
   * Sets the mesh and the geometry type [0=Mesh|1=LineSegments|2=Points]
   * @param {Mesh} mesh
   * @param {number} geometryType
   */
  setMesh(e, t) {
    this.message.meshName = e.name, this.setBufferGeometry(e.geometry, t);
  }
}
class Ee {
  pack(e, t, s) {
    const r = e;
    return r.message.buffers && (ye(s, r.message.bufferGeometry, r.message.buffers), G(r.message.buffers.values(), t, s)), t;
  }
  unpack(e, t) {
    const s = e, r = Object.assign(new Ce(), s);
    return r.message.bufferGeometry && (r.message.bufferGeometry = Ne(t, r.message.bufferGeometry)), r;
  }
}
const ye = (o, e, t) => {
  if (!(e instanceof S))
    return;
  const s = e.getAttribute("position"), r = e.getAttribute("normal"), i = e.getAttribute("uv"), a = e.getAttribute("color"), c = e.getAttribute("skinIndex"), l = e.getAttribute("skinWeight"), h = e.getIndex();
  N("position", s, o, t), N("normal", r, o, t), N("uv", i, o, t), N("color", a, o, t), N("skinIndex", c, o, t), N("skinWeight", l, o, t), N("index", h, o, t);
}, N = (o, e, t, s) => {
  if (e && e !== null) {
    const r = e.array;
    s.set(o, t ? r.slice(0) : r);
  }
}, Ne = (o, e) => {
  const t = new S();
  if (e) {
    if (e instanceof S)
      return e;
  } else
    return t;
  if (e.attributes) {
    const i = e.attributes;
    P(t, i.position, "position", o), P(t, i.normal, "normal", o), P(t, i.uv, "uv", o), P(t, i.color, "color", o), P(t, i.skinIndex, "skinIndex", o), P(t, i.skinWeight, "skinWeight", o);
  }
  if (e.index !== null) {
    const i = e.index;
    if (i) {
      const a = o ? i.array.slice(0) : i.array;
      t.setIndex(new v(a, i.itemSize, i.normalized));
    }
  }
  const s = e.boundingBox;
  s !== null && (t.boundingBox = Object.assign(new ce(), s));
  const r = e.boundingSphere;
  return r !== null && (t.boundingSphere = Object.assign(new he(), r)), t.uuid = e.uuid, t.name = e.name, t.groups = e.groups, t.drawRange = e.drawRange, t.userData = e.userData, t;
}, P = (o, e, t, s) => {
  if (e) {
    const r = s ? e.array.slice(0) : e.array;
    o.setAttribute(t, new v(r, e.itemSize, e.normalized));
  }
};
T.handler.set("MeshPayload", new Ee());
const R = class R extends ue {
  /**
   *
   * @param {LoadingManager} [manager]
   */
  constructor(t) {
    super(t);
    n(this, "parser", new pe());
    n(this, "baseObject3d", new K());
    n(this, "materialStore", new fe(!0));
    n(this, "materialPerSmoothingGroup", !1);
    n(this, "useOAsMesh", !1);
    n(this, "useIndices", !1);
    n(this, "disregardNormals", !1);
    n(this, "modelName", "noname");
    n(this, "callbacks");
    this.callbacks = {
      onLoad: void 0,
      onError: void 0,
      onProgress: void 0,
      onMeshAlter: void 0
    };
  }
  /**
   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
   *
   * @param {boolean} enabled True or false.
   * @param {boolean} debug True or false.
   *
   * @return {OBJLoader2}
   */
  setLogging(t, s) {
    return this.parser.setLogging(t, s), this;
  }
  /**
   * Tells whether a material shall be created per smoothing group.
   *
   * @param {boolean} materialPerSmoothingGroup=false
   * @return {OBJLoader2}
   */
  setMaterialPerSmoothingGroup(t) {
    return this.materialPerSmoothingGroup = t === !0, this;
  }
  /**
   * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of "o" can be enforced.
   *
   * @param {boolean} useOAsMesh=false
   * @return {OBJLoader2}
   */
  setUseOAsMesh(t) {
    return this.useOAsMesh = t === !0, this;
  }
  /**
   * Instructs loaders to create indexed {@link BufferGeometry}.
   *
   * @param {boolean} useIndices=false
   * @return {OBJLoader2}
   */
  setUseIndices(t) {
    return this.useIndices = t === !0, this;
  }
  /**
   * Tells whether normals should be completely disregarded and regenerated.
   *
   * @param {boolean} disregardNormals=false
   * @return {OBJLoader2}
   */
  setDisregardNormals(t) {
    return this.disregardNormals = t === !0, this;
  }
  /**
   * Set the name of the model.
   *
   * @param {string} modelName
   * @return {OBJLoader2}
   */
  setModelName(t) {
    return t.length > 0 && (this.modelName = t), this;
  }
  /**
   * Returns the name of the models
   * @return {String}
   */
  getModelName() {
    return this.modelName;
  }
  /**
   * Set the node where the loaded objects will be attached directly.
   *
   * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to
   * @return {OBJLoader2}
   */
  setBaseObject3d(t) {
    return this.baseObject3d = t, this;
  }
  /**
   * Clears materials object and sets the new ones.
   *
   * @param {Object} materials Object with named materials
   * @return {OBJLoader2}
   */
  setMaterials(t) {
    return this.materialStore.addMaterialsFromObject(t, !1), this;
  }
  /**
   * Register a function that is called when parsing was completed.
   *
   * @param {CallbackOnLoadType} onLoad
   * @return {OBJLoader2}
   */
  setCallbackOnLoad(t) {
    return this.callbacks.onLoad = t, this;
  }
  /**
   * Register a function that is used to report overall processing progress.
   *
   * @param {CallbackOnProgressMessageType} onProgress
   * @return {OBJLoader2}
   */
  setCallbackOnProgress(t) {
    return this.callbacks.onProgress = t, this;
  }
  /**
   * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.
   *
   * @param {CallbackOnErrorMessageType} onError
   * @return {OBJLoader2}
   */
  setCallbackOnError(t) {
    return this.callbacks.onError = t, this;
  }
  /**
   * Register a function that is called once a single mesh is available and it could be altered by the supplied function.
   *
   * @param {CallbackOnMeshAlterType} onMeshAlter
   * @return {OBJLoader2}
   */
  setCallbackOnMeshAlter(t) {
    return this.callbacks.onMeshAlter = t, this;
  }
  /**
   * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.
   *
   * @param {string}  url A string containing the path/URL of the file to be loaded.
   * @param {FileLoaderOnLoadType} [onLoad] A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.
   * @param {FileLoaderOnProgressType} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.
   * @param {FileLoaderOnErrorType} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.
   * @param {OnMeshAlterType} [onMeshAlter] Called after every single mesh is made available by the parser
   */
  load(t, s, r, i, a) {
    if (s instanceof Function)
      this.setCallbackOnLoad(s);
    else {
      const u = new Error("onLoad is not a function! Aborting...");
      throw this._onError(u), u;
    }
    (!i || !(i instanceof Function)) && (i = (u) => {
      if (Object.hasOwn(u, "currentTarget")) {
        const p = `Error occurred while downloading!
url: ` + u.currentTarget;
        this._onError(new Error(p));
      }
    }), t === void 0 && i(new ErrorEvent("An invalid url was provided. Unable to continue!"));
    let c = "";
    try {
      c = new URL(t).href;
    } catch {
      c = new URL(t, window.location.href).href;
    }
    let l = c;
    const h = c.split("/");
    if (h.length > 2) {
      l = h[h.length - 1];
      const u = h.slice(0, h.length - 1).join("/") + "/";
      u !== void 0 && (this.path = u);
    }
    if (!r || !(r instanceof Function)) {
      let u = 0, p = 0;
      r = (m) => {
        if (m.lengthComputable && (p = m.loaded / m.total, p > u)) {
          u = p;
          const b = `Download of "${t}": ${(p * 100).toFixed(2)}%`;
          this._onProgress(b);
        }
      };
    }
    a && this.setCallbackOnMeshAlter(a);
    const g = (u) => {
      this.parse(u);
    }, d = new Y(this.manager);
    d.setPath(this.path || this.resourcePath), d.setResponseType("arraybuffer"), d.load(l, g, r, i);
  }
  /**
   * Overrides the implementation of THREE.Loader, so it supports onMeshAlter.
   *
   * @param {string}  url A string containing the path/URL of the file to be loaded.
   * @param {FileLoaderOnProgressType} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.
   * @param {CallbackOnMeshAlterType} [onMeshAlter] Called after every single mesh is made available by the parser url
   * @returns Promise
   */
  loadAsync(t, s, r) {
    return new Promise((i, a) => {
      this.load(t, i, s, a, r);
    });
  }
  /**
   * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.
   *
   * @param {ArrayBuffer|string} content OBJ data as Uint8Array or String
   * @return {Object3D}
   */
  parse(t) {
    return this.parser.isLoggingEnabled() && (console.info("Using OBJLoader2 version: " + R.OBJLOADER2_VERSION), console.time("OBJLoader parse: " + this.modelName)), t instanceof ArrayBuffer ? (this.parser.isLoggingEnabled() && console.info("Parsing arrayBuffer..."), this.configure(), this.parser.execute(t)) : typeof t == "string" ? (this.parser.isLoggingEnabled() && console.info("Parsing text..."), this.configure(), this.parser.executeLegacy(t)) : this._onError(new Error("Provided objToParse was neither of type String nor Uint8Array! Aborting...")), this.parser.isLoggingEnabled() && console.timeEnd("OBJLoader parse: " + this.modelName), this.baseObject3d;
  }
  configure() {
    this.parser.setBulkConfig({
      materialPerSmoothingGroup: this.materialPerSmoothingGroup,
      useOAsMesh: this.useOAsMesh,
      useIndices: this.useIndices,
      disregardNormals: this.disregardNormals,
      modelName: this.modelName,
      materialNames: new Set(Array.from(this.materialStore.getMaterials().keys()))
    }), this.parser._onAssetAvailable = (t) => {
      const s = R.buildThreeMesh(t, this.materialStore.getMaterials(), this.parser.isDebugLoggingEnabled());
      s && (this._onMeshAlter(s, t.materialMetaInfo), this.baseObject3d.add(s));
    }, this.parser._onLoad = () => {
      this._onLoad();
    }, this.printCallbackConfig();
  }
  printCallbackConfig() {
    var t, s, r, i;
    if (this.parser.isLoggingEnabled()) {
      let a = "OBJLoader2 callback configuration:";
      this.callbacks.onProgress !== null && (a += `
	callbacks.onProgress: ${((t = this.callbacks.onProgress) == null ? void 0 : t.name) ?? void 0}`), this.callbacks.onError !== null && (a += `
	callbacks.onError: ${((s = this.callbacks.onError) == null ? void 0 : s.name) ?? void 0}`), this.callbacks.onMeshAlter !== null && (a += `
	callbacks.onMeshAlter: ${((r = this.callbacks.onMeshAlter) == null ? void 0 : r.name) ?? void 0}`), this.callbacks.onLoad !== null && (a += `
	callbacks.onLoad: ${((i = this.callbacks.onLoad) == null ? void 0 : i.name) ?? void 0}`), console.info(a);
    }
  }
  static buildThreeMesh({
    meshName: t,
    vertexFA: s,
    normalFA: r,
    uvFA: i,
    colorFA: a,
    indexUA: c,
    createMultiMaterial: l,
    geometryGroups: h,
    multiMaterial: g,
    materialMetaInfo: d
  }, u, p) {
    const m = new S();
    if (m.setAttribute("position", new v(s, 3, !1)), r !== null && m.setAttribute("normal", new v(r, 3, !1)), i !== null && m.setAttribute("uv", new v(i, 2, !1)), a !== null && m.setAttribute("color", new v(a, 3, !1)), c !== null && m.setIndex(new v(c, 1, !1)), h.length > 0)
      for (const w of h)
        m.addGroup(w.materialGroupOffset, w.materialGroupLength, w.materialIndex);
    r === null && m.computeVertexNormals();
    let b;
    if (d.materialCloneInstructions.length > 0)
      for (const w of d.materialCloneInstructions)
        b = O.cloneMaterial(u, w, p);
    else
      b = u.get(d.materialName);
    const f = [];
    if (l)
      for (let w = 0; w < g.length; w++) {
        const y = u.get(g[w]);
        y && (f[w] = y);
      }
    let E;
    const L = l ? f : b;
    return d.geometryType === 0 ? E = new de(m, L) : d.geometryType === 1 ? E = new ge(m, L) : E = new me(m, L), E && (E.name = t), E;
  }
  _onProgress(t) {
    this.callbacks.onProgress ? this.callbacks.onProgress(t) : this.parser._onProgress(t);
  }
  _onError(t) {
    this.callbacks.onError ? this.callbacks.onError(t) : this.parser._onError(t.message);
  }
  _onMeshAlter(t, s) {
    this.callbacks.onMeshAlter && this.callbacks.onMeshAlter(t, this.baseObject3d);
  }
  _onLoad() {
    this.callbacks.onLoad && this.callbacks.onLoad(this.baseObject3d);
  }
};
n(R, "OBJLOADER2_VERSION", "6.0.0");
let I = R;
const M = class M extends I {
  /**
   *
   * @param {LoadingManager} [manager]
   */
  constructor(t) {
    super(t);
    n(this, "moduleWorker", !0);
    n(this, "workerUrl", M.getModuleWorkerDefaultUrl());
    n(this, "terminateWorkerOnLoad", !1);
    n(this, "workerTask");
  }
  /**
   * Set whether jsm modules in workers should be used. This requires browser support
   * which is availableminall major browser apart from Firefox.
   *
   * @param {boolean} moduleWorker If the worker is a module or a standard worker
   * @param {URL} workerUrl Provide complete worker URL otherwise relative path to this module may not be correct
   * @return {OBJLoader2Parallel}
   */
  setWorkerUrl(t, s) {
    return this.moduleWorker = t === !0, this.workerUrl = s, this;
  }
  static getModuleWorkerDefaultUrl() {
    return new URL(M.DEFAULT_PROD_MODULE_WORKER_PATH, import.meta.url);
  }
  static getStandardWorkerDefaultUrl() {
    return new URL(M.DEFAULT_PROD_STANDARD_WORKER_PATH, import.meta.url);
  }
  /**
   * Request termination of worker once parser is finished.
   *
   * @param {boolean} terminateWorkerOnLoad True or false.
   * @return {OBJLoader2Parallel}
   */
  setTerminateWorkerOnLoad(t) {
    return this.terminateWorkerOnLoad = t === !0, this;
  }
  /**
   * See {@link OBJLoader2.load}
   */
  load(t, s, r, i, a) {
    const c = (l) => {
      if (l.name === "OBJLoader2ParallelDummy")
        this.parser.isDebugLoggingEnabled() && console.debug("Received dummy answer from OBJLoader2Parallel#parse");
      else if (s)
        s(l);
      else
        throw new Error('"onLoad" callback was not provided. Aborting...');
    };
    I.prototype.load.call(this, t, c, r, i, a);
  }
  /**
   * See {@link OBJLoader2.parse}
   * The callback onLoad needs to be set to be able to receive the content if used in parallel mode.
   */
  parse(t) {
    this.parser.isLoggingEnabled() && console.info("Using OBJLoader2Parallel version: " + M.OBJLOADER2_PARALLEL_VERSION), this.printCallbackConfig(), this.initWorkerParse(t);
    const s = new K();
    return s.name = "OBJLoader2ParallelDummy", s;
  }
  async initWorkerParse(t) {
    this.workerTask = new be({
      taskName: M.TASK_NAME,
      workerId: 1,
      workerConfig: {
        $type: "WorkerConfigParams",
        workerType: this.moduleWorker ? "module" : "classic",
        blob: !1,
        url: this.workerUrl
      },
      verbose: this.parser.isDebugLoggingEnabled()
    });
    try {
      await this.initWorker(), this.parser.isDebugLoggingEnabled() && console.log("OBJLoader2Parallel init was performed"), this.executeWorker(t);
    } catch (s) {
      console.error(s);
    }
  }
  /**
   * Provide instructions on what is to be contained in the worker.
   *
   * @return {Promise<void>}
   * @private
   */
  initWorker() {
    const t = new B();
    return t.message.params = {
      logging: {
        enabled: this.parser.isLoggingEnabled(),
        debug: this.parser.isDebugLoggingEnabled()
      }
    }, this.workerTask.connectWorker(), this.workerTask.initWorker({ message: C.fromPayload(t) });
  }
  async executeWorker(t) {
    var a, c;
    const s = C.createEmpty(), r = new B();
    r.message.params = {
      modelName: this.modelName,
      useIndices: this.useIndices,
      disregardNormals: this.disregardNormals,
      materialPerSmoothingGroup: this.materialPerSmoothingGroup,
      useOAsMesh: this.useOAsMesh,
      logging: {
        enabled: this.parser.isLoggingEnabled(),
        debug: this.parser.isDebugLoggingEnabled()
      }
    }, (a = r.message.buffers) == null || a.set("modelData", t), r.message.params.materialNames = new Set(Array.from(this.materialStore.getMaterials().keys())), s.addPayload(r);
    const i = C.pack(s.payloads, !1);
    try {
      await ((c = this.workerTask) == null ? void 0 : c.executeWorker({
        message: s,
        onIntermediateConfirm: (l) => {
          this.onWorkerMessage(l);
        },
        onComplete: (l) => {
          this.onWorkerMessage(l), this.terminateWorkerOnLoad && this.workerTask.dispose();
        },
        transferables: i
      })), console.log("Worker execution completed successfully.");
    } catch (l) {
      console.error(l);
    }
  }
  /**
   *
   * @param {Mesh} mesh
   * @param {object} materialMetaInfo
   */
  onWorkerMessage(t) {
    const s = C.unpack(t, !1);
    if (s.cmd === A.INTERMEDIATE_CONFIRM) {
      const r = s.payloads.length === 1 ? s.payloads[0] : void 0;
      if (r && r.message.params) {
        const i = r.message.params.preparedMesh, a = I.buildThreeMesh(i, this.materialStore.getMaterials(), this.parser.isDebugLoggingEnabled());
        a && (this._onMeshAlter(a, i.materialMetaInfo), this.baseObject3d.add(a));
      } else
        console.error("Received intermediate message without a proper payload");
    } else
      s.cmd === A.EXECUTE_COMPLETE ? this._onLoad() : console.error(`Received unknown command: ${s.cmd}`);
  }
};
n(M, "OBJLOADER2_PARALLEL_VERSION", I.OBJLOADER2_VERSION), n(M, "DEFAULT_DEV_MODULE_WORKER_PATH", "./worker/OBJLoader2Worker.js"), n(M, "DEFAULT_DEV_STANDARD_WORKER_PATH", "../lib/worker/OBJLoader2WorkerClassic.js"), n(M, "DEFAULT_PROD_MODULE_WORKER_PATH", "./worker/OBJLoader2WorkerModule.js"), n(M, "DEFAULT_PROD_STANDARD_WORKER_PATH", "./worker/OBJLoader2WorkerClassic.js"), n(M, "TASK_NAME", "OBJLoader2Worker");
let X = M;
class Q {
  link(e, t) {
    typeof t.setMaterials == "function" && t.setMaterials(Q.addMaterialsFromMtlLoader(e));
  }
  /**
   * Returns the array instance of {@link Material}.
   *
   * @param {MTLLoader.MaterialCreator} materialCreator instance of MTLLoader
   */
  static addMaterialsFromMtlLoader(e) {
    return e.preload(), e.materials;
  }
}
class Oe {
  constructor(e) {
    n(this, "url");
    n(this, "path", "./");
    n(this, "filename");
    n(this, "extension");
    n(this, "buffer");
    n(this, "needStringOutput", !1);
    this.url = new URL(e, window.location.href), this.filename = e;
    const t = this.url.href.split("/");
    if (t.length > 2) {
      this.filename = t[t.length - 1];
      const r = t.slice(0, t.length - 1).join("/") + "/";
      r !== void 0 && (this.path = r);
    }
    const s = this.filename.split(".");
    s.length > 1 && (this.extension = s[s.length - 1]);
  }
  getUrl() {
    return this.url;
  }
  /**
   * Returns ths path from the base of the URL to the file
   * @return {string}
   */
  getPath() {
    return this.path;
  }
  getFilename() {
    return this.filename;
  }
  getExtension() {
    return this.extension;
  }
  setNeedStringOutput(e) {
    return this.needStringOutput = e, this;
  }
  isNeedStringOutput() {
    return this.needStringOutput;
  }
  /**
   * Set the buffer after loading.
   * @param {ArrayBufferLike} buffer
   * @return {ResourceDescriptor}
   */
  setBuffer(e) {
    if (e instanceof ArrayBuffer || e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array)
      this.buffer = e;
    else
      throw new Error('Provided input is neither an "ArrayBuffer" nor a "TypedArray"! Aborting...');
    return this;
  }
  getBuffer() {
    return this.buffer;
  }
  /**
   * Returns the buffer as string by using {@link TextDecoder}.
   *
   * @return {string}
   */
  getBufferAsString() {
    return this.buffer ? new TextDecoder("utf-8").decode(this.buffer) : "";
  }
}
class Le {
  constructor(e, t) {
    n(this, "name");
    n(this, "assetPipeline");
    n(this, "baseObject3d");
    n(this, "onComplete", null);
    this.name = e, this.assetPipeline = t;
  }
  getName() {
    return this.name;
  }
  setBaseObject3d(e) {
    return this.baseObject3d = e, this;
  }
  setOnComplete(e) {
    this.onComplete = e;
  }
  run() {
    if (this.assetPipeline.initPipeline(this.name, this.onComplete), this.baseObject3d)
      this.assetPipeline.runPipeline(this.baseObject3d);
    else
      throw new Error("baseObject3d was not properly specified.");
    return this;
  }
}
class Pe {
  constructor() {
    n(this, "name", null);
    n(this, "onComplete", null);
    n(this, "assetTasks", /* @__PURE__ */ new Map());
  }
  addAssetTask(e) {
    return this.assetTasks.set(e.getName(), e), this;
  }
  /**
   * Init all {@link AssetTask}
   *
   * @param {string} name Name of the pipeline
   * @param {CallbackCompleteType} onComplete set callback function
   * @return {AssetPipeline}
   */
  initPipeline(e, t) {
    this.name = e, this.onComplete = t;
    let s = null;
    for (const r of this.assetTasks.values())
      s !== null && (r.setTaskBefore(s), s.setTaskAfter(r)), s = r, r.init();
    return this;
  }
  /**
   * Run the pipeline: First load resources and then execute the parsing functions
   * @param {Object3D} baseObject3d
   * @return {AssetPipeline}
   */
  async runPipeline(e) {
    const t = this.onComplete ? this.onComplete : (i) => {
      console.log("Done loading: " + i);
    }, s = async (i) => {
      const a = [];
      for (const c of i.values())
        if (c.getResourceDescriptor()) {
          const l = c.loadResource();
          a.push(l);
        }
      return console.log("Waiting for completion of loading of all assets!"), await Promise.all(a);
    }, r = (i) => {
      console.log("Count of loaded resources: " + i.length);
      let a;
      for (a of this.assetTasks.values())
        a.process();
      return a && a.getProcessResult() && e.add(a.getProcessResult()), e;
    };
    try {
      const i = await s(this.assetTasks), a = r(i);
      t(this.name, a);
    } catch (i) {
      console.error(i);
    }
  }
}
class Ie {
  constructor(e) {
    n(this, "name");
    n(this, "resourceDescriptor");
    n(this, "assetLoader", {
      loader: {
        instance: void 0,
        config: {}
      },
      linker: void 0
    });
    n(this, "relations", {
      before: void 0,
      after: void 0
    });
    n(this, "processResult");
    this.name = e;
  }
  getName() {
    return this.name;
  }
  setResourceDescriptor(e) {
    return this.resourceDescriptor = e, this;
  }
  getResourceDescriptor() {
    return this.resourceDescriptor;
  }
  setTaskBefore(e) {
    this.relations.before = e;
  }
  setTaskAfter(e) {
    this.relations.after = e;
  }
  getProcessResult() {
    return this.processResult;
  }
  setLinker(e) {
    this.assetLoader.linker = e;
  }
  setLoader(e, t) {
    const s = e;
    if (typeof s.parse == "function")
      this.assetLoader.loader.instance = s;
    else
      throw new Error("Provide loader has now parse method! Aborting...");
    return this.assetLoader.loader.config = t ?? {}, this;
  }
  init() {
    console.log(this.name + ": Performing init"), we(this.assetLoader.loader.instance, this.assetLoader.loader.config, !1);
  }
  async loadResource() {
    const e = new Y();
    if (e.setResponseType("arraybuffer"), this.resourceDescriptor) {
      const t = await e.loadAsync(this.resourceDescriptor.getUrl().href);
      return this.resourceDescriptor.setBuffer(t), Promise.resolve(this.resourceDescriptor);
    } else
      return Promise.reject();
  }
  process() {
    var e, t, s, r;
    if (this.assetLoader.linker) {
      const i = (e = this.relations.before) == null ? void 0 : e.processResult, a = (t = this.relations.after) == null ? void 0 : t.assetLoader.loader.instance;
      i && (this.processResult = this.assetLoader.linker.link(i, a));
    } else if (this.assetLoader.loader.instance)
      if ((s = this.resourceDescriptor) != null && s.isNeedStringOutput()) {
        const i = this.resourceDescriptor.getBufferAsString();
        this.processResult = this.assetLoader.loader.instance.parse(i);
      } else {
        const i = (r = this.resourceDescriptor) == null ? void 0 : r.getBuffer();
        this.processResult = this.assetLoader.loader.instance.parse(i);
      }
  }
}
export {
  Pe as AssetPipeline,
  Le as AssetPipelineLoader,
  Ie as AssetTask,
  Q as MtlObjBridge,
  I as OBJLoader2,
  X as OBJLoader2Parallel,
  pe as OBJLoader2Parser,
  Oe as ResourceDescriptor
};
